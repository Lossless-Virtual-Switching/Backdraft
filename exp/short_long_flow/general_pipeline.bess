"""
FlowGen Pipeline Configuration
"""
import os
import sys
import yaml
import subprocess
import scapy.all as scapy
import json


# pipeline config
config = json.load(open('.pipeline_config.json'))

out_pci = config['pci']
count_queue = config['count_queue']
count_tas_queues = count_queue 
size_q = config['queue_size']


# cluster config file
config_file = './cluster_config.yml'


def get_mac_address():
  """
  Get current device MAC address
  """
  p = subprocess.Popen('cat /sys/class/net/eno50/address', shell=True, stdout=subprocess.PIPE)
  res, _ = p.communicate()
  add = res.decode().strip()
  return add


def get_pci_address(iface):
  """
  Get PCI address for the given interface name
  """
  # ethtool -i iface # this should give enough information  
  raise Exception('Not implemented yet')


def get_current_node_info(file_path):
  mac = get_mac_address()
  found = False
  with open(file_path) as f:
    config = yaml.load(f)
    for key in config.keys():
      if key == 'connections':
        continue
      item = config[key]
      if item['mac'] == mac:
        found = True
        break
  if not found:
    return (None, None)
  return (key, item)


def get_tci(prio, dei, vlan_id):
  tci = prio << 13 | 0 << 12 | vlan_id  
  return tci


name, info =  get_current_node_info(config_file)
instances = info['instances']
count_instances = len(instances)
if count_instances == 0:
  raise Exception('This node has no instace!')


# PCI of port connected to switch
sw_port = PMDPort(pci=out_pci, num_inc_q=count_queue, num_out_q=count_queue)

# TAS vhost ports
vhosts = []
for i, instance in enumerate(instances):
  name = 'tas_{}_{}'.format(instance['type'], i)
  tas_socket = '/tmp/{}.sock'.format(name)

  # Make sure previous socket file is removed
  if os.path.exists(tas_socket):
    # os.remove(tas_socket)
    subprocess.call('sudo rm {}'.format(tas_socket), shell=True)
    print('previous socket file removed')

  vdev = 'eth_vhost{},iface={},queues={}'.format(i, tas_socket, count_tas_queues)
  tas_port = PMDPort(name=name,
    vdev=vdev,
    num_inc_q=count_tas_queues,
    num_out_q=count_tas_queues,
    size_inc_q=size_q,
    size_out_q=size_q)
  ip = info['ip'] 
  if 'ip' in instance:
    ip = instance['ip']
  vhosts.append((tas_port, ip))


# Pipeline
# sw_q_inc = QueueInc(port=sw_port.name, qid=0)
# sw_q_out = QueueOut(port=sw_port.name, qid=0)
# merge = Merge() # merge input 
# x = HashLB(gates=[i for i in range(count_instances)], mode='l4')

# # Tx
# for i, vhost in enumerate(vhosts):
#   qinc = QueueInc(port=vhost.name, qid=0)
#   qinc -> merge:i
# merge -> sw_q_out
# 
# # Rx
# sw_q_inc -> x
# for i, vhost in enumerate(vhosts):
#   qout = QueueOut(port=vhost.name, qid=0)
#   x:i -> qout 
# 

bp = config['bp']
buffering = config['buffering'] 
cdq = config['cdq'] 
pfq = config['pfq'] 
overlay = config['overlay']

sw_merge = Merge()
for i in range(count_queue):
  sw_q_inc = BKDRFTQueueInc(port=sw_port, qid=i, cdq=cdq, backpressure=bp, overlay=overlay)
  sw_q_inc -> sw_merge:i

sw_q_out = BKDRFTQueueOut(port=sw_port, qid=0, count_queues=count_queue,
  backpressure=bp, lossless=buffering, cdq=cdq, per_flow_buffering=pfq, mname='sw',
  overlay = overlay)

merge = Merge() # merge input 
# x = HashLB(gates=[i for i in range(count_instances)], mode='l4')
# TODO: this part does not scale. each instance can have its own ip. then
# IPLookup can be used with a replicate module for passing arp and other
# packets.
x = IPLookup()
x.add(prefix='0.0.0.0', prefix_len=0, gate=0)
rep = Replicate(gates=[i + 1 for i in range(len(vhosts))])
x:0 -> rep


# Tx
gate = 0
lookup_gate = 1
for i, (vhost, ip) in enumerate(vhosts):
  for j in range(count_queue):
    qinc = BKDRFTQueueInc(port=vhost, qid=j, cdq=cdq, backpressure=bp, overlay=overlay)
    qinc -> merge:gate
    gate += 1
  if ip is not None:
    lookup_gate += 1
    print(ip, ' : ', lookup_gate)
    x.add(prefix=ip, prefix_len=32, gate=lookup_gate)
push_vlan = VLANPush(tci=get_tci(3, 0, 100))
merge -> push_vlan -> sw_q_out
# merge -> sw_q_out

#TODO: if two instance have the same ip we will have problems
# Rx
pop_vlan = VLANPop()
sw_merge -> pop_vlan -> x
# sw_merge -> x
lookup_gate = 1
# x:0 -> rep
for i, (vhost, ip) in enumerate(vhosts):
  qout = BKDRFTQueueOut(port=vhost, qid=0, count_queues=count_queue,
    backpressure=bp, lossless=buffering, cdq=cdq, per_flow_buffering=pfq,
    mname=vhost.name + '_' + str(i), overlay=overlay)
  if ip:
    lookup_gate += 1
    x:lookup_gate -> qout 
  gate = i + 1
  rep:gate -> qout

