"""
FlowGen Pipeline Configuration
"""
import os
import sys
import yaml
import subprocess
import scapy.all as scapy
import json


# pipeline config
config = json.load(open('.pipeline_config.json'))

out_pci = config['pci']
count_queue = config['count_queue']
count_tas_queues = count_queue
size_q = config['queue_size']


# cluster config file
config_file = './cluster_config.yml'


def get_mac_address():
  """
  Get current device MAC address
  """
  p = subprocess.Popen('cat /sys/class/net/eno50/address', shell=True, stdout=subprocess.PIPE)
  res, _ = p.communicate()
  add = res.decode().strip()
  return add


def get_pci_address(iface):
  """
  Get PCI address for the given interface name
  """
  # ethtool -i iface # this should give enough information
  raise Exception('Not implemented yet')


def get_current_node_info(file_path):
  mac = get_mac_address()
  found = False
  with open(file_path) as f:
    config = yaml.load(f)
    for key in config.keys():
      if key == 'connections':
        continue
      item = config[key]
      if item['mac'] == mac:
        found = True
        break
  if not found:
    return (None, None)
  return (key, item)


def get_tci(prio, dei, vlan_id):
  tci = prio << 13 | 0 << 12 | vlan_id
  return tci


host_name, info =  get_current_node_info(config_file)
instances = info.get('instances', [])
count_instances = len(instances)
# if count_instances == 0:
#   raise Exception('This node has no instace!')

bp = config['bp']
buffering = config['buffering']
cdq = config['cdq']
pfq = config['pfq']
overlay = config['overlay']


# PCI of port connected to switch
# if host_name == 'node4':
#   # HARD CODED: Slow down node 4 port
#   sw_port = PMDPort(pci=out_pci, num_inc_q=count_queue, num_out_q=count_queue,
#              rate_limiting=True, rate=1, command_queue=cdq, data_mapping=cdq)
# else:
sw_port = PMDPort(pci=out_pci, num_inc_q=count_queue, num_out_q=count_queue,
           rate_limiting=overlay, rate=40, command_queue=cdq, data_mapping=cdq)

# TAS vhost ports
vhosts = []
for i, instance in enumerate(instances):
  name = 'tas_{}_{}'.format(instance['type'], i)
  tas_socket = '/tmp/{}.sock'.format(name)

  # Make sure previous socket file is removed
  if os.path.exists(tas_socket):
    # os.remove(tas_socket)
    subprocess.call('sudo rm {}'.format(tas_socket), shell=True)
    print('previous socket file removed')

  vdev = 'eth_vhost{},iface={},queues={}'.format(i, tas_socket, count_tas_queues)
  tas_port = PMDPort(name=name,
    vdev=vdev,
    num_inc_q=count_tas_queues,
    num_out_q=count_tas_queues,
    size_inc_q=size_q,
    size_out_q=size_q,
    rate_limiting=overlay,
    rate=40)
  ip = info['ip']
  if 'ip' in instance:
    ip = instance['ip']
  ip = ip.strip()
  vhosts.append((tas_port, ip))


# Pipeline
# sw_q_inc = QueueInc(port=sw_port.name, qid=0)
# sw_q_out = QueueOut(port=sw_port.name, qid=0)
# merge = Merge() # merge input 
# x = HashLB(gates=[i for i in range(count_instances)], mode='l4')

# # Tx
# for i, vhost in enumerate(vhosts):
#   qinc = QueueInc(port=vhost.name, qid=0)
#   qinc -> merge:i
# merge -> sw_q_out
#
# # Rx
# sw_q_inc -> x
# for i, vhost in enumerate(vhosts):
#   qout = QueueOut(port=vhost.name, qid=0)
#   x:i -> qout
#

sw_merge = Merge()
if not cdq:
  for i in range(count_queue):
    sw_q_inc = BKDRFTQueueInc(port=sw_port, qid=i, cdq=cdq, backpressure=bp, overlay=overlay)
    sw_q_inc -> sw_merge:i
else:
  sw_q_inc = BKDRFTQueueInc(port=sw_port, qid=0, cdq=cdq, backpressure=bp, overlay=overlay)
  sw_q_inc -> sw_merge:0

sw_q_out = BKDRFTQueueOut(port=sw_port, qid=0, count_queues=count_queue,
  backpressure=bp, lossless=buffering, cdq=cdq, per_flow_buffering=pfq, mname='sw',
  overlay = overlay)

merge = Merge() # merge input 
x = IPLookup()
x.add(prefix='0.0.0.0', prefix_len=0, gate=0)
rep = Replicate(gates=[i + 1 for i in range(len(vhosts))])
x:0 -> rep

x.add(prefix='192.0.0.0', prefix_len=8, gate=8000)
x:8000 -> Sink()

# ACL for filtering unwanted packets
rules = [ {'src_ip': '192.168.9.50', 'dst_ip':'',
           'src_port':10001, 'dst_port':8080,
           'drop':True},]
acl = ACL(rules=rules)


# Tx
gate = 0
lookup_gate = 1
for i, (vhost, ip) in enumerate(vhosts):
  if not cdq:
    for j in range(count_queue):
      qinc = BKDRFTQueueInc(port=vhost, qid=j, cdq=cdq, backpressure=bp, overlay=overlay)
      qinc -> merge:gate
      gate += 1
  else:
    qinc = BKDRFTQueueInc(port=vhost, qid=0, cdq=cdq, backpressure=bp, overlay=overlay)
    qinc -> merge:gate
    gate += 1
  if ip is not None:
    print(ip, ' : ', lookup_gate)
    x.add(prefix=ip, prefix_len=32, gate=lookup_gate)
    lookup_gate += 1
push_vlan = VLANPush(tci=get_tci(3, 0, 100))
merge -> push_vlan -> sw_q_out
# merge -> sw_q_out

#TODO: if two instance have the same ip we will have problems
# Rx
pop_vlan = VLANPop()
sw_merge -> pop_vlan -> acl -> x
# sw_merge -> x
lookup_gate = 1
for i, (vhost, ip) in enumerate(vhosts):
  qout = BKDRFTQueueOut(port=vhost, qid=0, count_queues=count_queue,
    backpressure=bp, lossless=buffering, cdq=cdq, per_flow_buffering=pfq,
    mname=vhost.name + '_' + str(i), overlay=overlay)
  if ip:
    x:lookup_gate -> qout
    lookup_gate += 1
  gate = i + 1
  rep:gate -> qout

# HARD CODED BURST GENERATOR
import scapy.all as scapy

if host_name in ('node5', 'node2'):
  payload_size = 100
  pps = 1.0e6
  if host_name == 'node2':
    pps = 0.8e6
    payload_size = 1400
  src_mac = info['mac']
  dst_mac = '98:f2:b3:cc:02:c1' # TODO: this should be read from config file
  src_ip = '192.168.9.50'  # this ip should be dropped in vsw
  dst_ip = '192.168.1.41'  # TODO: this should be read from config
  eth = scapy.Ether(src=src_mac, dst=dst_mac)
  ip = scapy.IP(src=src_ip, dst=dst_ip)
  tcp = scapy.TCP(sport=10001, dport=8080, seq=134)
  payload = 'a' * payload_size
  pkt = bytes(eth/ip/tcp/payload)

  src::FlowGen(template=pkt, pps=pps, flow_rate=800, flow_duration=1.0, \
      arrival='exponential', duration='pareto', quick_rampup=True) -> merge

# FOR ALL INSTANCES
x.add(prefix='192.168.9.50', prefix_len=32, gate=8000)

