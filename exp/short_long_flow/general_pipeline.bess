"""
FlowGen Pipeline Configuration
"""
import os
import sys
import yaml
import subprocess
import scapy.all as scapy
import json


# pipeline config
config = json.load(open('.pipeline_config.json'))


out_pci = config['pci']
count_queue = 1
count_tas_queues = count_queue 
size_q = 64

# cluster config file
config_file = './cluster_config.yml'


def get_mac_address():
	"""
	Get current device MAC address
	"""
	p = subprocess.Popen('cat /sys/class/net/eno50/address', shell=True, stdout=subprocess.PIPE)
	res, _ = p.communicate()
	print ('hello', res)
	add = res.decode().strip()
	return add


def get_pci_address(iface):
	"""
	Get PCI address for the given interface name
	"""
	# ethtool -i iface # this should give enough information	
	raise Exception('Not implemented yet')


def get_current_node_info(file_path):
	mac = get_mac_address()
	found = False
	with open(file_path) as f:
		config = yaml.load(f)
		for key in config.keys():
			if key == 'connections':
				continue
			item = config[key]
			if item['mac'] == mac:
				found = True
				break
	if not found:
		return (None, None)
	return (key, item)


name, info =  get_current_node_info(config_file)
instances = info['instances']
count_instances = len(instances)
if count_instances == 0:
	raise Exception('This node has no instace!')


# PCI of port connected to switch
sw_port = PMDPort(pci=out_pci)

# TAS vhost ports
vhosts = []
for i, instance in enumerate(instances):
	name = 'tas_{}_{}'.format(instance['type'], i)
	tas_socket = '/tmp/{}.sock'.format(name)

	# Make sure previous socket file is removed
	if os.path.exists(tas_socket):
		# os.remove(tas_socket)
	        subprocess.call('sudo rm {}'.format(tas_socket), shell=True)
        	print('previous socket file removed')

	vdev = 'eth_vhost{},iface={},queues={}'.format(i, tas_socket, count_tas_queues)
	tas_port = PMDPort(name=name,
		vdev=vdev,
		num_inc_q=count_tas_queues,
		num_out_q=count_tas_queues,
		size_inc_q=size_q,
		size_out_q=size_q)
	vhosts.append(tas_port)


# Pipeline
# sw_q_inc = QueueInc(port=sw_port.name, qid=0)
# sw_q_out = QueueOut(port=sw_port.name, qid=0)
# merge = Merge() # merge input 
# x = HashLB(gates=[i for i in range(count_instances)], mode='l4')

# # Tx
# for i, vhost in enumerate(vhosts):
# 	qinc = QueueInc(port=vhost.name, qid=0)
# 	qinc -> merge:i
# merge -> sw_q_out
# 
# # Rx
# sw_q_inc -> x
# for i, vhost in enumerate(vhosts):
# 	qout = QueueOut(port=vhost.name, qid=0)
# 	x:i -> qout 
# 

bp = config['bp']
buffering = config['buffering'] 
cdq = config['cdq'] 
pfq = config['pfq'] 
overlay = config['overlay']

sw_q_inc = BKDRFTQueueInc(port=sw_port, qid=0, cdq=cdq, backpressure=bp, overlay=overlay)
sw_q_out = BKDRFTQueueOut(port=sw_port, qid=0, count_queues=count_queue,
  backpressure=bp, lossless=buffering, cdq=cdq, per_flow_buffering=pfq, mname='sw',
  overlay = overlay)

merge = Merge() # merge input 
x = HashLB(gates=[i for i in range(count_instances)], mode='l4')

# Tx
for i, vhost in enumerate(vhosts):
	qinc = BKDRFTQueueInc(port=vhost, qid=0, cdq=cdq, backpressure=bp, overlay=overlay)
	qinc -> merge:i
merge -> sw_q_out

# Rx
sw_q_inc -> x
for i, vhost in enumerate(vhosts):
	qout = BKDRFTQueueOut(port=vhost, qid=0, count_queues=count_queue,
	  backpressure=bp, lossless=buffering, cdq=cdq, per_flow_buffering=pfq,
	  mname=vhost.name + '_' + str(i), overlay=overlay)
	x:i -> qout 

