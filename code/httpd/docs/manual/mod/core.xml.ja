<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE modulesynopsis SYSTEM "../style/modulesynopsis.dtd">
<?xml-stylesheet type="text/xsl" href="../style/manual.ja.xsl"?>
<!-- English Revision: 669847:1879472 (outdated) -->

<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<modulesynopsis metafile="core.xml.meta">

<name>core</name>
<description>常に使用可能な Apache HTTP サーバのコア機能</description>
<status>Core</status>

<directivesynopsis>
<name>AcceptFilter</name>
<description>プロトコルを Listen しているソケットの最適化を設定する</description>
<syntax>AcceptFilter <var>protocol</var> <var>accept_filter</var></syntax>
<contextlist><context>server config</context></contextlist>
<compatibility>2.1.5 以降</compatibility>

<usage>
    <p>Listen しているソケットに対して、OS が固有に持っているプロトコルについての最適化を
       有効にするディレクティブです。大前提となる条件は、データが受信されるか
       HTTP リクエスト全体がバッファされるかするまで、カーネルがサーバプロセスに
       ソケットを送らないようになっている、ということです。現在サポートされているのは、
       <a href="http://www.freebsd.org/cgi/man.cgi?query=accept_filter&amp;sektion=9">
       FreeBSD の Accept Filter</a> と Linux のプリミティブな
       <code>TCP_DEFER_ACCEPT</code> のみです。</p>

    <p>FreeBSD のデフォルト値は :</p>
    <example>
        AcceptFilter http httpready <br/>
        AcceptFilter https dataready
    </example>
    
    <p><code>httpready</code> Accept Filter は HTTP リクエスト全体を、
       カーネルレベルでバッファリングします。リクエスト全体を受信し終わると、
       その後サーバプロセスにそれを送ります。詳細については <a 
       href="http://www.freebsd.org/cgi/man.cgi?query=accf_http&amp;sektion=9">accf_http(9)</a> 
       を参照してください。HTTPS のリクエストは暗号化されているので <a 
       href="http://www.freebsd.org/cgi/man.cgi?query=accf_data&amp;sektion=9">accf_data(9)</a>
       フィルタのみが使用されます。</p>

    <p>Linux でのデフォルト値は :</p>
    <example>
        AcceptFilter http data <br/>
        AcceptFilter https data
    </example>

    <p>Linux の <code>TCP_DEFER_ACCEPT</code> は HTTP リクエストのバッファリングを
       サポートしていません。<code>none</code> 以外の値で
       <code>TCP_DEFER_ACCEPT</code> が有効になります。詳細については Linux 
       man ページ <a 
       href="http://homepages.cwi.nl/~aeb/linux/man2html/man7/tcp.7.html">tcp(7)</a>
       を参照してください。</p>

    <p>引数に <code>none</code> を指定すると、プロトコルに対する全ての Accept 
       Filter が無効になります。<code>nntp</code> といった、先にサーバにデータを
       送る必要のあるプロトコルに有効です :</p>
    <example>AcceptFilter nntp none</example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>AcceptPathInfo</name>
<description>後に続くパス名情報を受け付けるリソースの指定</description>    
<syntax>AcceptPathInfo On|Off|Default</syntax>
<default>AcceptPathInfo Default</default>
<contextlist><context>server config</context>
<context>virtual host</context><context>directory</context>
<context>.htaccess</context></contextlist>
<override>FileInfo</override>
<compatibility>Apache 2.0.30 以降で使用可能</compatibility>

<usage>

    <p>このディレクティブは実際のファイル名 (もしくは存在するディレクトリの
    存在しないファイル) の後に続くパス名情報があるリクエストを受け付けるか
    拒否するかを制御します。続きのパス名情報はスクリプトには <code>PATH_INFO</code>
    環境変数として利用可能になります。</p>

    <p>例えば、<code>/test/</code> が、<code>here.html</code> というファイル
    一つのみがあるディレクトリを指しているとします。そうすると、
    <code>/test/here.html/more</code> と <code>/test/nothere.html/more</code>
    へのリクエストは両方とも <code>/more</code> を <code>PATH_INFO</code> とします。</p>

    <p><directive>AcceptPathInfo</directive> ディレクティブに指定可能な
    三つの引数は:</p>

    <dl>
    <dt><code>Off</code></dt><dd>リクエストは存在するパスにそのまま
    マップされる場合にのみ受け付けられます。ですから、上の例の
    <code>/test/here.html/more</code> のように、本当のファイル名の
    後にパス名情報が続くリクエストには 404 NOT FOUND エラーが返ります。</dd>

    <dt><code>On</code></dt><dd>前の方のパスが存在するファイルにマップする場合は
    リクエストが受け付けられます。上の例の <code>/test/here.html/more</code>
    は <code>/test/here.html</code> が有効なファイルにマップすれば
    受け付けられます。</dd>
    
    <dt><code>Default</code></dt><dd>続きのパス名情報の扱いはリクエストの
    <a href="../handler.html">ハンドラ</a>で決まります。
    普通のファイルのためのコアハンドラのデフォルトは <code>PATH_INFO</code> を拒否します。
    <a href="mod_cgi.html">cgi-script</a> や <a
    href="mod_isapi.html">isapi-handler</a> のようにスクリプトを扱うハンドラは
    一般的にデフォルトで <code>PATH_INFO</code> を受け付けます。</dd>
    </dl>

    <p><code>AcceptPathInfo</code> の主な目的はハンドラの <code>PATH_INFO</code> を
    受け付けるか拒否するかの選択を上書きできるようにすることです。
    例えば、これは例えば <a href="mod_include.html">INCLUDES</a> のような
    <a href="../filter.html">フィルタ</a>を使って <code>PATH_INFO</code> に
    基づいてコンテンツを生成しているときに必要になります。
    コアハンドラでは通常拒否されるので、そういったスクリプトを動作させるには
    次のような設定を使います。</p>

    <example>
      &lt;Files "mypaths.shtml"&gt;<br />
      <indent>
        Options +Includes<br />
        SetOutputFilter INCLUDES<br />
        AcceptPathInfo On<br />
      </indent>
      &lt;/Files&gt;
    </example>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>AccessFileName</name>
<description>分散設定ファイルの名前</description>
<syntax>AccessFileName <var>filename</var> [<var>filename</var>] ...</syntax>
<default>AccessFileName .htaccess</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p>リクエストを処理するとき、サーバはディレクトリに
    対して分散設定ファイルが<a href="#allowoverride">有効になっていれば</a>、
    そのドキュメントへの
    パス上にある全てのディレクトリから、ここで指定された名前の一覧の中で
    最初に見つかったファイルをそれぞれ設定ファイルとして読み込みます。例えば:</p>

    <example>
      AccessFileName .acl
    </example>

    <p>という設定があると、以下のようにして無効にされていない限り、
    ドキュメント <code>/usr/local/web/index.html</code>
    を返す前に、サーバは <code>/.acl</code>, <code>/usr/.acl</code>,
    <code>/usr/local/.acl</code>, <code>/usr/local/web/.acl</code> から
    ディレクティブを読み込みます。</p>

    <example>
      &lt;Directory /&gt;<br />
      <indent>
        AllowOverride None<br />
      </indent>
      &lt;/Directory&gt;
    </example>
</usage>
<seealso><directive module="core">AllowOverride</directive></seealso>
<seealso><a href="../configuring.html">設定ファイル</a></seealso>
<seealso><a href="../howto/htaccess.html">.htaccess ファイル</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>AddDefaultCharset</name>
<description>レスポンスのコンテントタイプが <code>text/plain</code> あるいは
<code>text/html</code> の場合に追加するデフォルトの charset パラメータ</description>
<syntax>AddDefaultCharset On|Off|<var>charset</var></syntax>
<default>AddDefaultCharset Off</default>
<contextlist><context>server config</context>
<context>virtual host</context><context>directory</context>
<context>.htaccess</context></contextlist>
<override>FileInfo</override>

<usage>
    <p>レスポンスのコンテントタイプが <code>text/plain</code> 
    あるいは <code>text/html</code> 
    の場合に限りますが、レスポンスに追加するメディアタイプの文字セットパラメータ
    (文字エンコーディングの名前) のデフォルト値を、このディレクティブで指定します。
    これはレスポンス <transnote>レスポンスの HTML</transnote> 内で <code>META</code> 
    要素で指定された、どのような文字セットも無効にしますが、
    最終的な挙動はユーザのクライアント側の設定で決まります。
    この機能は <code>AddDefaultCharset Off</code> という設定で無効になります。
    <code>AddDefaultCharset On</code> にすれば、
    Apache 内部のデフォルト文字セット <code>iso-8859-1</code> に設定されます。
    その他 <var>charset</var> に指定できる値であれば、どんな値でも使えます。
    指定する値は、MIME メディアタイプとして使われる
    <a href="http://www.iana.org/assignments/character-sets">IANA 
    に登録されている文字セット名</a>のうちの一つにすべきです。
    例えば:</p>

    <example>
      AddDefaultCharset utf-8
    </example>

    <p><directive>AddDefaultCharset</directive> を使うときは、全てのテキストリソースが
    指定する文字エンコードになっていると分かっていて、かつ、
    リソースの個々に文字セットを指定するのが大変な場合のみです。
    例を挙げると、レガシーな CGI スクリプトなどの、動的に生成される
    コンテンツを含むリソースに文字セットパラメータを追加する場合で、
    ユーザの入力データが出力に入り、クロスサイトスクリプティングが
    引き起こされうる場合です。デフォルト文字セットをセットしたとしても、
    ブラウザの "文字エンコードの自動選択" 機能が有効になっているユーザを
    守ることにはならないので、もちろんより良い解決策は単にスクリプトを修正
    (あるいは削除) することです。</p>
</usage>
<seealso><directive module="mod_mime">AddCharset</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>AddOutputFilterByType</name>
<description>MIME-type に出力フィルタを割り当てる</description>
<syntax>AddOutputFilterByType <var>filter</var>[;<var>filter</var>...] <var>MIME-type</var>
[<var>MIME-type</var>] ...</syntax>
<contextlist><context>server config</context>
<context>virtual host</context><context>directory</context>
<context>.htaccess</context></contextlist>
<override>FileInfo</override>
<compatibility>Apache 2.0.33 以降で使用可能; Apache 2.1 以降非推奨</compatibility>

<usage>
    <p>このディレクティブは応答の <glossary ref="mime-type">MIME タイプ</glossary> に応じて出力<a
    href="../filter.html">フィルタ</a>を使用するようにします。
    しかし後述する問題のため、このディレクティブは非推奨です。
    同等の機能は <module>mod_filter</module> で実現可能です。</p>

    <p>次の例は <module>mod_deflate</module> の <code>DEFLATE</code> フィルタを
    使っています。<code>text/html</code> と <code>text/plain</code> の
    すべての出力 (静的なものも動的なものも) をクライアントに送られる前に
    圧縮します。</p>

    <example>
      AddOutputFilterByType DEFLATE text/html text/plain
    </example>

    <p>複数のフィルタでコンテンツを処理させたいときは、それぞれの名前をセミコロンで
    分ける必要があります。各フィルタに対して
    <directive>AddOutputFilterByType</directive> を一つずつ書くこともできます。</p>

    <p>次の例は <code>text/html</code> のスクリプトのすべての出力を
    まず <code>INCLUDES</code> フィルタで処理し、さらに <code>DEFLATE</code> フィルタにかけます。</p>

    <example>
    &lt;Location /cgi-bin/&gt;<br />
    <indent>
      Options Includes<br />
      AddOutputFilterByType INCLUDES;DEFLATE text/html<br />
    </indent>
    &lt;/Location&gt;
    </example>

    <note type="warning"><title>注:</title>
      <p><directive>AddOutputFilterByType</directive> ディレクティブにより
      有効にしたフィルタは場合によっては、部分的もしくは完全に適用されないことが
      あります。例えば、<glossary ref="mime-type">MIME タイプ</glossary> が決定できないときには
      <directive module="core">DefaultType</directive> の設定が同じだったとしても、
      <directive module="core">DefaultType</directive> 設定を使うようになります。</p>
      <p>しかし、確実にフィルタが適用されるようにしたいときは、リソースに
      明示的にコンテントタイプを割り当てることができます。これには例えば
      <directive module="mod_mime">AddType</directive> ディレクティブや
      <directive module="core">ForceType</directive> ディレクティブを使います。
      (nphでない) CGI スクリプトでコンテントタイプを設定するというものでも
      大丈夫です。</p>
    </note>
</usage>

<seealso><directive module="mod_mime">AddOutputFilter</directive></seealso>
<seealso><directive module="core">SetOutputFilter</directive></seealso>
<seealso><a href="../filter.html">フィルタ</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>AllowEncodedSlashes</name>
<description>URL 中の符号化されたパス分離文字が先に伝えられるのを許可するかどうかを
決定する</description>
<syntax>AllowEncodedSlashes On|Off</syntax>
<default>AllowEncodedSlashes Off</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>
<compatibility>Apache 2.0.46 以降で使用可能</compatibility>

<usage>
    <p><directive>AllowEncodedSlashes</directive> ディレクティブは符号化された
    パス分離文字 (<code>/</code> は <code>%2F</code>、さらにシステムによっては
    <code>\</code> に対応する <code>%5C</code>) が存在する URL の使用を
    許可するかどうかを決定します。通常はそのような URL は 404 (Not found) エラー
    で拒否されます。</p>

    <p><directive>AllowEncodedSlashes</directive> <code>On</code> による
    パス分離文字の使用は、<code>PATH_INFO</code> と合わせて
    使うときに一番役に立ちます。</p>

    <note><title>注</title>
      <p>符号化されたスラッシュを許可することは、<em>復号</em>をすることを
       意味<em>しません</em>。<code>%2F</code> や (関係するシステムでの)
       <code>%5C</code> は、他の部分が復号された URL の中でもそのままの形式で
       残されます。</p>
    </note>
</usage>
<seealso><directive module="core">AcceptPathInfo</directive></seealso>
</directivesynopsis>


<directivesynopsis>
<name>AllowOverride</name>
<description><code>.htaccess</code> で許可されるディレクティブの種類</description>
<syntax>AllowOverride All|None|<var>directive-type</var> 
[<var>directive-type</var>] ...</syntax>
<default>AllowOverride All</default>
<contextlist><context>directory</context></contextlist>

<usage>
    <p>サーバが (<directive
    module="core">AccessFileName</directive> によって指定された)
    <code>.htaccess</code> ファイルを見つけた時、そのファイルの中で
    宣言されたどのディレクティブがより前に定義された設定ディレクティブを
    上書きできるかを知る必要があります。</p>

    <note><title>&lt;Directory&gt; セクションでのみ使用可能</title>
    <directive>AllowOverride</directive> は正規表現無しの<directive
    type="section" module="core">Directory</directive>
    セクションでのみ有効で、<directive type="section"
    module="core">Location</directive> や <directive
    module="core" type="section">DirectoryMatch</directive>
    や <directive type="section"
    module="core">Files</directive> セクションでは無効です。
    </note>

    <p>このディレクティブを <code>None</code> に設定すると、<a href="#accessfilename">.htaccess</a> ファイルは完全に
    無視されます。
    この場合、サーバはファイルシステムの <code>.htaccess</code> ファイルを読むことを
    試みさえしません。</p>

    <p>このディレクティブが <code>All</code> に設定されている時には、
    <code>.htaccess</code> という <a
    href="directive-dict.html#Context">コンテキスト</a> を持つ
    全てのディレクティブが利用できます。</p>

    <p><var>directive-type</var> には、以下のディレクティブ群の
    キーワードのどれかを指定します。</p>

    <dl>
      <dt>AuthConfig</dt>

      <dd>

      認証に関するディレクティブの使用を許可する (<directive
      module="mod_authn_dbm">AuthDBMGroupFile</directive>,
      <directive module="mod_authn_dbm">AuthDBMUserFile</directive>,
      <directive module="mod_authz_groupfile">AuthGroupFile</directive>,
      <directive module="mod_authn_core">AuthName</directive>, 
      <directive module="mod_authn_core">AuthType</directive>, <directive
      module="mod_authn_file">AuthUserFile</directive>, <directive
      module="mod_authz_core">Require</directive> <em>など</em>)。</dd>

      <dt>FileInfo</dt>

      <dd>
      ドキュメントタイプを制御するためのディレクティブの使用を許可する (<directive
      module="core">DefaultType</directive>, <directive
      module="core">ErrorDocument</directive>, <directive
      module="core">ForceType</directive>, <directive
      module="mod_negotiation">LanguagePriority</directive>,
      <directive module="core">SetHandler</directive>, <directive
      module="core">SetInputFilter</directive>, <directive
      module="core">SetOutputFilter</directive>, 
      <module>mod_mime</module> の Add* と Remove*
      ディレクティブ<em>など</em>),
      ドキュメントのメタデータ (<directive
      module="mod_headers">Header</directive>, <directive
      module="mod_headers">RequestHeader</directive>, <directive
      module="mod_setenvif">SetEnvIf</directive>, <directive
      module="mod_setenvif">SetEnvIfNoCase</directive>, <directive
      module="mod_setenvif">BrowserMatch</directive>, <directive
      module="mod_usertrack">CookieExpires</directive>, <directive
      module="mod_usertrack">CookieDomain</directive>, <directive
      module="mod_usertrack">CookieStyle</directive>, <directive
      module="mod_usertrack">CookieTracking</directive>, <directive
      module="mod_usertrack">CookieName</directive>),
      <module>mod_rewrite</module> のディレクティブ <directive
      module="mod_rewrite">RewriteEngine</directive>, <directive
      module="mod_rewrite">RewriteOptions</directive>, <directive
      module="mod_rewrite">RewriteBase</directive>, <directive
      module="mod_rewrite">RewriteCond</directive>, <directive
      module="mod_rewrite">RewriteRule</directive>) と
      <module>mod_actions</module> の
      <directive module="mod_actions">Action</directive>
      ディレクティブ。
      </dd>

      <dt>Indexes</dt>

      <dd>
      ディレクトリインデックスを制御するためのディレクティブの使用を許可する
      (<directive
      module="mod_autoindex">AddDescription</directive>,
      <directive module="mod_autoindex">AddIcon</directive>, <directive
      module="mod_autoindex">AddIconByEncoding</directive>,
      <directive module="mod_autoindex">AddIconByType</directive>,
      <directive module="mod_autoindex">DefaultIcon</directive>, <directive
      module="mod_dir">DirectoryIndex</directive>, <directive
      module="mod_autoindex">FancyIndexing</directive>, <directive
      module="mod_autoindex">HeaderName</directive>, <directive
      module="mod_autoindex">IndexIgnore</directive>, <directive
      module="mod_autoindex">IndexOptions</directive>, <directive
      module="mod_autoindex">ReadmeName</directive>
      <em>など</em>)。</dd>

      <dt>Limit</dt>

      <dd>
      ホストへのアクセス制御を行うためのディレクティブの使用を許可する (<directive
      module="mod_authz_host">Allow</directive>, <directive
      module="mod_authz_host">Deny</directive>, <directive
      module="mod_authz_host">Order</directive>).</dd>

      <dt>Options[=<var>Option</var>,...]</dt>

      <dd>
      特定のディレクトリにおける機能を指定するためのディレクティブの使用を許可する
      (<directive module="core">Options</directive> と
      <directive module="mod_include">XBitHack</directive>)。
      <directive module="core">Options</directive> で設定するオプション
      を、(空白を含めない) コンマ区切りのリストにして等号の後に続けることで
      設定できます。</dd>
    </dl>

    <p>例:</p>

    <example>
      AllowOverride AuthConfig Indexes
    </example>

    <p>上の例では <code>AuthConfig</code> と <code>Indexes</code> のどちらにも
    属さないディレクティブはすべて内部サーバエラーを引き起こします。</p>
</usage>

<seealso><directive module="core">AccessFileName</directive></seealso>
<seealso><a href="../configuring.html">設定ファイル</a></seealso>
<seealso><a href="../howto/htaccess.html">.htaccess ファイル</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>CGIMapExtension</name>
<description>CGI スクリプトのインタープリタの位置を調べるための手法</description>
<syntax>CGIMapExtension <var>cgi-path</var> <var>.extension</var></syntax>
<contextlist><context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>
<compatibility>NetWare のみ</compatibility>

<usage>
    <p>このディレクティブは Apache が CGI スクリプトを実行するための
    インタープリタを探す方法を制御します。
    例えば、<code>CGIMapExtension sys:\foo.nlm .foo</code> と設定すると
    <code>.foo</code> という拡張子のすべての CGI スクリプトは FOO インタープリタに
    渡されます。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>ContentDigest</name>
<description><code>Content-MD5</code> HTTP 応答ヘッダの生成を有効にする</description> 
<syntax>ContentDigest On|Off</syntax>
<default>ContentDigest Off</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>Options</override>
<status>Experimental</status>

<usage>
    <p>このディレクティブは、RFC1864 及び RFC2616 において定義されている
    <code>Content-MD5</code> ヘッダーの生成を有効にします。</p>

    <p>MD5 は、任意長のデータの「メッセージダイジェスト」(「指紋」
    と表現されることもある) を計算するアルゴリズムで、
    データの変更があった場合には非常に高い信頼度でメッセージダイジェストに変更が
    反映されます。</p>

    <p><code>Content-MD5</code> ヘッダは、エンドツーエンドで
    エンティティボディーに含まれるメッセージの完全性チェック
    (Message Integrity Check - MIC)を提供します。
    このヘッダを調べることで、プロキシやクライアントは、
    途中経路におけるエンティティボディの予期せぬ変更などを
    検出することができます。ヘッダの例:</p>

    <example>
      Content-MD5: AuLb7Dp1rqtRtxz2m9kRpA==
    </example>

    <p>リクエスト毎にメッセージダイジェストを計算する (値はキャッシュされません)
    ことから、
    サーバパフォーマンスが低下することについて注意してください。</p>

    <p><code>Content-MD5</code >は、<module>core</module> 機能により処理された
    ドキュメントを送るときのみ有効であり、
    SSI ドキュメントや CGI スクリプトの出力、バイトレンジを指定した
    応答の場合にはこのヘッダは付与されません。
    </p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>DefaultType</name>
<description>サーバがコンテントタイプを決定できないときに
送られる MIME コンテントタイプ</description>
<syntax>DefaultType <var>MIME-type|none</var></syntax>
<default>DefaultType text/plain</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>
<compatibility>引数 <code>none</code> は Apache 2.2.7 以降で利用可能</compatibility>
<usage>
    <p>サーバは、<glossary ref="mime-type">MIME タイプ</glossary>
    のマップからは決定できないドキュメントの送信を要求されることがあります。</p>

    <p>サーバは、ドキュメントのコンテントタイプをクライアントに通知するべきです。
    サーバで通常の方法ではこれが判定できない場合は、
    <code>DefaultType</code> で指定されたタイプを利用します。
    例:</p>

    <example>
      DefaultType image/gif
    </example>

    <p>これは <code>.gif</code> という拡張子がファイル名に含まれていない
    多くの GIF 画像が含まれているディレクトリに適しているでしょう。</p>

    <p>サーバでも管理者でも判定することができない (例えばプロクシの) 場合、
    誤った情報を与えるよりは MIME タイプの指定がない状態が望ましいことも
    あります。この場合は次のようにします :</p>
    <example>
      DefaultType None
    </example>
    <p><code>DefaultType None</code> は httpd-2.2.7 
    以降でのみ利用できます。</p>

    <p><directive module="core">ForceType</directive> ディレクティブと
    違って、このディレクティブはデフォルトの MIME タイプを提供するだけで
    あることに注意してください。ファイル名の拡張子を含め、
    メディアタイプを決定できる他の MIME タイプの定義があれば
    このデフォルトは上書きされます。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>Define</name>
<description>変数の存在を宣言する</description>
<syntax>Define <var>parameter-name</var></syntax>
<contextlist><context>server config</context></contextlist>

<usage>
    <p><program>httpd</program> の <code>-D</code>
    引数と同じものです。</p>
    <p>このディレクティブを使うと、スタートアップスクリプトに
    記載されている <code>-D</code> 引数を書き換える必要なく、
    <directive module="core" type="section">IfDefine</directive>
    セクションを切り替えることができます。</p>
</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>Directory</name>
<description>指定のファイルシステムのディレクトリとサブディレクトリとのみに
適用されるディレクティブを囲む</description>
<syntax>&lt;Directory <var>directory-path</var>&gt;
... &lt;/Directory&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p>指定されたディレクトリとそのサブディレクトリにのみ
    ディレクティブを適用させるためには、
    <directive type="section">Directory</directive> と 
    <code>&lt;/Directory&gt;</code> を対として、ディレクティブ群を囲います。
    その中には、ディレクトリコンテキストで許可された全てのディレクティブを
    利用できます。
    <var>directive-path</var> は、フルパスもしくは Unix のシェル形式の
    ワイルドカードを指定します。
    <code>?</code> は任意の 1 文字、<code>*</code> は任意の文字列にマッチします。
    シェルにおける指定同様、文字の範囲を <code>[]</code> で指定できます。
    ワイルドカードは `/' 文字にはマッチしませんので、
    <code>/home/user/public_html</code> には
    <code>&lt;Directory /*/public_html&gt;</code> はマッチしませんが、
    <code>&lt;Directory /home/*/public_html&gt;</code> はマッチします。
    例:</p>

    <example>
      &lt;Directory /usr/local/httpd/htdocs&gt;<br />
      <indent>
        Options Indexes FollowSymLinks<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <note>
      <p><var>directory-path</var> 引数には注意してください: その引数は
      Apache がファイルをアクセスするために使うファイルシステムのパスに
      そのままマッチする必要があります。ある <code>&lt;Directory&gt;</code> に
      適用されるディレクティブは、別のシンボリックリンクをたどったりして
      同じディレクトリを違うパスでアクセスした場合には適用されません。</p>
    </note>

    <p><code>~</code> という文字を
    付加することで<glossary ref="regex">正規表現</glossary>を利用することもできます。
    例えば:</p>

    <example>
      &lt;Directory ~ "^/www/.*/[0-9]{3}"&gt;
    </example>

    <p>といった指定の場合、<code>/www/</code> 以下にある数字
    3 文字のディレクトリにマッチします。</p>

    <p>もし複数の (正規表現以外の) <directive type="section"
    >Directory</directive>セクションが
    ドキュメントを含むディレクトリ (やその上位ディレクトリのどれか) とマッチしたならば、
    <a
    href="#accessfilename">.htaccess</a> ファイルのディレクティブも読み込みつつ、
    短いパスから順に適用されます。
    例えば、</p>

    <example>
      &lt;Directory /&gt;<br />
      <indent>
        AllowOverride None<br />
      </indent>
      &lt;/Directory&gt;<br />
      <br />
      &lt;Directory /home/&gt;<br />
      <indent>
        AllowOverride FileInfo<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p>と設定し、ドキュメント <code>/home/web/dir/doc.html</code> への
    アクセスがあった場合には以下のように動作します:</p>

    <ul>
      <li><code>AllowOverride None</code> が適用される。
      (<code>.htaccess</code> ファイルは無効になる)</li>

      <li><code>AllowOverride FileInfo</code> が適用される
      (<code>/home</code> ディレクトリに対して)。</li>

      <li><code>/home/.htaccess</code>, <code>/home/web/.htaccess</code>,
      <code>/home/web/dir/.htaccess</code> の順にそれらのファイル中の
       FileInfo ディレクティブが適用される。</li>
    </ul>

    <p>正規表現は、通常のセクションがすべて適用されるまで
    考慮されません。
    その後、全ての正規表現が設定ファイルに現れた順で試されます。
    例えば、以下のような場合に</p>

    <example>
      &lt;Directory ~ abc$&gt;<br />
      <indent>
        # ... directives here ...<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p>正規表現のセクションはすべての通常の <directive
    type="section">Directory</directive> と
    <code>.htaccess</code> の適用が終わるまで考慮されません。
    その後で、正規表現は <code>/home/abc/public_html/abc</code> にマッチし、
    対応する <directive type="section">Directory</directive> が適用されます。</p>

    <p><strong>Apache のデフォルトでは <code>&lt;Directory /&gt;</code> へのアクセスは
    <code>Allow from All</code> になっていることに注意してください。
    これは、URL からマップされたどのファイルでも Apache は送るということです。
    これは以下のようにして変更することが推奨されています。</strong></p>

    <example>
      &lt;Directory /&gt;<br />
      <indent>
        Order Deny,Allow<br />
        Deny from All<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p><strong>そしてアクセスを<em>可能にしたい</em>ディレクトリに対して
    個別に設定すればよいでしょう。
    このあたりについては、<a
    href="../misc/security_tips.html">セキュリティに関するコツ</a>を
    参照してください。</strong></p>

    <p>ディレクトリセクションは <code>httpd.conf</code> ファイルに書きます。
    <directive type="section">Directory</directive>
    ディレクティブは入れ子にすることができず、
    <directive module="core" type="section">Limit</directive> や <directive
    module="core" type="section">LimitExcept</directive> セクションの中にも
    記述できません。</p>

</usage>
<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

<directivesynopsis type="section">
<name>DirectoryMatch</name>
<description>正規表現にマッチするファイルシステムのディレクトリと
サブディレクトリとのみに適用されるディレクティブを囲む</description>
<syntax>&lt;DirectoryMatch <var>regex</var>&gt;
... &lt;/DirectoryMatch&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive module="core" type="section">Directory</directive>
    ディレクティブと同様に、<directive type="section">DirectoryMatch</directive>
    と <code>&lt;/DirectoryMatch&gt;</code> は指定されたディレクトリと
    そのサブディレクトリにのみ適用されるディレクティブ群を囲います。
    しかし、このディレクティブは引数として<glossary 
    ref="regex">正規表現</glossary>をとります。例えば:</p>

    <example>
      &lt;DirectoryMatch "^/www/(.+/)?[0-9]{3}"&gt;
    </example>

    <p>は <code>/www/</code> 以下にある数字 3 文字のディレクトリにマッチします。</p>

</usage>
<seealso>通常の <directive type="section">Directory</directive> と正規表現の指定が
適用される順番については <directive type="section"
module="core">Directory</directive></seealso>
<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>DocumentRoot</name>
<description>ウェブから見えるメインのドキュメントツリーになる
ディレクトリ</description>
<syntax>DocumentRoot <var>directory-path</var></syntax>
<default>DocumentRoot /usr/local/apache/htdocs</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p>このディレクティブは、<program>httpd</program>
    がファイルを提供するディレクトリを設定します。
     <directive module="mod_alias">Alias</directive> のようなディレクティブにマッチしない場合には、
    ドキュメントの (訳注:ファイルシステム上の) パスを生成するために、
    リクエストされた URL のパス部分をドキュメントルートに付与します。
    例:</p>

    <example>
      DocumentRoot /usr/web
    </example>

    <p>この場合、
    <code>http://www.my.host.com/index.html</code> へのアクセスがあれば
    <code>/usr/web/index.html</code> が返されます。
    <var>directory-path</var> が絶対パスでない場合は、
    <directive module="core">ServerRoot</directive> 
    からの相対パスとみなされます。</p>

    <p><directive>DocumentRoot</directive> は最後のスラッシュ無しで
    指定する必要があります。</p>
</usage>
<seealso><a href="../urlmapping.html#documentroot">URL をファイルシステムの位置に
マップする</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>EnableMMAP</name>
<description>配送中にファイルを読み込むためにメモリマッピングを
使うかどうか</description>
<syntax>EnableMMAP On|Off</syntax>
<default>EnableMMAP On</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>

<usage>
    <p>このディレクティブは配送中にファイルの内容を読み込む必要があるときに
    <program>httpd</program> がメモリマッピングを使うかどうかを制御します。
    デフォルトでは、
    例えば、<module>mod_include</module> を使って SSI ファイルを配送
    するときのように、ファイルの途中のデータをアクセスする必要があるときには
    Apache は OS がサポートしていればファイルをメモリにマップします。</p>

    <p>
    このメモリマップは性能の向上をもたらすことがあります。
    しかし、環境によっては運用上の問題を防ぐためにメモリマッピングを
    使用しないようにした方が良い場合もあります:</p>

    <ul>
    <li>マルチプロセッサシステムの中にはメモリマッピングをすると
    <program>httpd</program> の性能が落ちるものがあります。</li>
    <li>NFS マウントされた <directive module="core">DocumentRoot</directive>
    では、<program>httpd</program> がメモリマップしている間にファイルが削除されたり
    短くなったりしたときに起こるセグメンテーションフォールトのために
    <program>httpd</program> がクラッシュする可能性があります。</li>
    </ul>

    <p>これらの問題に当てはまるサーバの設定の場合は、以下のようにして
    ファイルの配送時のメモリマッピングを使用不可にしてください:</p>

    <example>
      EnableMMAP Off
    </example>

    <p>NFS マウントされたファイルには、問題のあるファイルにのみ明示的に
    この機能を使用不可にします:</p>

    <example>
      &lt;Directory "/path-to-nfs-files"&gt;
      <indent>
        EnableMMAP Off
      </indent>
      &lt;/Directory&gt;
    </example>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>EnableSendfile</name>
<description>ファイルのクライアントへの配送時にカーネルの sendfile サポートを
使うかどうか</description>
<syntax>EnableSendfile On|Off</syntax>
<default>EnableSendfile On</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>
<compatibility>バージョン 2.0.44 以降で使用可能</compatibility>

<usage>
    <p>このディレクティブはクライアントにファイルの内容を送るときに
    <program>httpd</program> がカーネルの
    sendfile サポートを使うかどうかを制御します。デフォルトでは、
    例えば静的なファイルの配送のように、リクエストの処理にファイルの
    途中のデータのアクセスを必要としないときには、Apache は OS が
    サポートしていればファイルを読み込むことなく sendfile を使って
    ファイルの内容を送ります。</p>

    <p>sendfile は read と send を別々に行なうことと、バッファの割り当てを
    回避します。しかし、プラットフォームやファイルシステムの中には
    運用上の問題を避けるためにこの機能を使用不可にした方が良い場合があります:</p>

    <ul>
    <li>プラットフォームの中にはビルドシステムが検知できなかった、壊れた
    sendfile のサポートが存在するものがあります。これは特に
    バイナリが別のマシンでビルドされ、壊れた sendfile のあるマシンに
    移動したときに起こります。</li>
    <li>Linux では、sendfile を用いると、
    IPv6 使用時に存在する特定ネットワークカードの TCP-checksum
    オフロードのバグを踏んでしまいます。</li>
    <li>Itanium 上の Linux では、sendfile では 2GB 以上の
    ファイルを扱うことができません。</li>
    <li>ネットワークマウントされた <directive module="core">DocumentRoot</directive>
    (例えば NFS や SMB)
    では、カーネルは自身のキャッシュを使ってネットワークからのファイルを
    送ることができないことがあります。</li>
    </ul>

    <p>これらの問題に当てはまるサーバの設定の場合は、以下のようにして
    この機能を使用不可にしてください:</p>


    <example>
      EnableSendfile Off
    </example>

    <p>NFS や SMB マウントされたファイルには、問題のあるファイルにのみ明示的に
    この機能を使用不可にします:</p>

    <example>
      &lt;Directory "/path-to-nfs-files"&gt;
      <indent>
        EnableSendfile Off
      </indent>
      &lt;/Directory&gt;
    </example>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>ErrorDocument</name>
<description>エラーが発生したときにサーバがクライアントに送るもの</description>
<syntax>ErrorDocument <var>error-code document</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>

<usage>
    <p>問題やエラーが発生したときの動作として、
    Apache には以下の四つのうち一つの動作を設定することができます。</p>

    <ol>
      <li>Apache 標準の簡単なエラーメッセージを表示</li>

      <li>自分で指定したメッセージを表示</li>

      <li>問題やエラーの処理をする為に、自サーバ内の
      <var>URL-path</var> へリダイレクト</li>

      <li>問題やエラーの処理をする為に、外部の <var>URL</var> へリダイレクト</li>
    </ol>

    <p>最初のものがデフォルトの動作で、2 番目から 4 番目は、
    <directive>ErrorDocument</directive>ディレクティブにより、
    HTTP のレスポンスコードと、メッセージか URL を指定することで設定します。
    Apache が問題もしくはエラーに関する追加情報を提供することがあります。</p>

    <p>URL の場合は、スラッシュで始まる (/) ローカルの web-path (
    <directive module="core">DocumentRoot</directive> からの相対パス
    ) か、クライアントが解決できる完全な URL を指定します。
    もしくは、ブラウザに表示されるメッセージを指定できます。
    例:</p>

    <example>
      ErrorDocument 500 http://foo.example.com/cgi-bin/tester<br />
      ErrorDocument 404 /cgi-bin/bad_urls.pl<br />
      ErrorDocument 401 /subscription_info.html<br />
      ErrorDocument 403 "Sorry can't allow you access today"
    </example>

    <p>加えて、特別な値 <code>default</code> を使って Apache に
    ハードコードされている簡単なメッセージを指定することができます。
    通常は必要ではありませんが、<code>default</code> を使うと
    既存の <directive>ErrorDocument</directive> ディレクティブの設定を
    継承するところで、Apache のハードコードされた簡単なメッセージに
    戻すことができます。</p>

    <example>
      ErrorDocument 404 /cgi-bin/bad_urls.pl<br /><br />
      &lt;Directory /web/docs&gt;<br />
      <indent>
        ErrorDocument 404 default<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p>リモート URL (例えば、頭に <code>http</code> と付与した方法) を
    <directive>ErrorDocument</directive> に指定するとき、
    たとえ文書が同じサーバにあろうとも、ドキュメントがどこにあるかを通知するために、
    Apache はリダイレクトをクライアントに送出するということに、注意してください。
    これにはいろいろと関連して起こる問題があります。
    中でも最も重要なのは、クライアントは元々のエラーステータスコードを受け取らず、
    代わりにリダイレクトのステータスコードを受け取るということです。
    これにより、ステータスコードを使って URL が有効であるかどうかを決定しようとする
    ウェブロボットやその他クライアントを、混乱させるかもしれません。
    さらに、<code>ErrorDocument 401</code> にリモートの URL を指定すると、
    クライアントは 401 というステータスコードを受け取らないため、
    パスワードをユーザーに入力要求しなければならないことがわかりません。
    従って、<strong><code>ErrorDocument 401</code> というディレクティブを使う場合は、
    必ずローカルな文書を参照しなければなりません。</strong></p>

    <p>Microsoft Internet Explorer (MSIE) はデフォルトではサーバが生成したエラーメッセージが
    「小さすぎる」ときには無視をして自分自身の「やさしい」エラーメッセージで
    置換します。サイズのしきい値はエラーの種類によって異なりますが、
    一般的にはエラーの文書を 512 バイトよりも大きくすると、MSIE は
    サーバが生成したエラーを隠さずに表示します。詳しい情報は Microsoft
    Knowledge Base の記事 <a
    href="http://support.microsoft.com/default.aspx?scid=kb;en-us;Q294807">Q294807</a>
    にあります。</p>

    <p>ほとんどのエラーメッセージを上書きすることができますが、特定の状況下では
    <directive module="core">ErrorDocument</directive> の設定にかかわらず
    内蔵のメッセージが使われます。
    特に、不正な形式のリクエストが検出された場合、通常のリクエスト処理は
    即座に中止され、内蔵のエラーメッセージが返されます。
    この処置は不正なリクエストによって引き起こされる、セキュリティ問題から
    守るために必要な措置です。</p>

    <p>2.0 より前のバージョンでは、対になっていない二重引用符を
    先頭に付けることによりメッセージであることを指定していました。</p>

</usage>

<seealso><a href="../custom-error.html">カスタマイズ可能な
エラー応答のドキュメンテーション</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ErrorLog</name>
<description>サーバがエラーをログ収集する場所</description>    
<syntax> ErrorLog <var>file-path</var>|syslog[:<var>facility</var>]</syntax>
<default>ErrorLog logs/error_log (Unix) ErrorLog logs/error.log (Windows and OS/2)</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive>ErrorLog</directive> ディレクティブは、
    サーバに生じたさまざまなエラーを
    記録する為のファイルの名前を設定します。
    <var>file-path</var> が絶対パスでないときは、<directive
    module="core">ServerRoot</directive> からの相対パスとみなされます。</p>

    <example><title>例</title>
    ErrorLog /var/log/httpd/error_log
    </example>
    
    <p><var>file-path</var> がパイプ (|) から始まる場合は、
    エラーログを処理するために実行されるコマンドが
    指定されていると解釈されます。</p>

    <example><title>例</title>
    ErrorLog "|/usr/local/bin/httpd_errors"
    </example>

    <p>ファイル名の変わりに <code>syslog</code> と指定することによって、
    システムがサポートしていれば syslogd(8) を利用したロギングが有効になります。
    デフォルトでは、<code>local7</code> ファシリティとなりますが、
    <code>syslog:<var>facility</var></code> といった形で記述することにより、
    通常 syslog(1) のドキュメントで説明されているファシリティの一つを使うように
    することができます。</p>

    <example><title>例</title>
    ErrorLog syslog:user
    </example>

    <p>セキュリティ: 
    ログファイルを格納するディレクトリが、サーバを起動したユーザ以外の
    ユーザによって書き込める場合にセキュリティが破られる可能性があることに
    関する詳細は <a
    href="../misc/security_tips.html#serverroot">セキュリティに関するコツ</a> を
    参照してください。</p>
    <note type="warning"><title>注</title>
      <p>Unix 以外のプラットフォームでファイルのパスを入力するときは、
      プラットフォームがバックスラッシュの使用を許していたとしても、
      確実にスラッシュのみが使用されるように注意してください。一般的には、
      設定ファイル全般でスラッシュのみを使う方が良いでしょう。</p>
    </note>
</usage>
<seealso><directive module="core">LogLevel</directive></seealso>
<seealso><a href="../logs.html">Apache ログファイル</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>FileETag</name>
<description>ETag HTTP 応答ヘッダを作成するために使用される
ファイルの属性</description>
<syntax>FileETag <var>component</var> ...</syntax>
<default>FileETag INode MTime Size</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>

<usage>
    <p>
    <directive>FileETag</directive> ディレクティブは
    ドキュメントがファイルに基づいたものであるときに、
    <code>ETag</code> (エンティティタグ) 応答ヘッダフィールドを作成するときに使用する
    ファイルの属性を設定します。 (<code>ETag</code> の値はネットワークの帯域を節約するための
    キャッシュの管理で使われます。) Apache 1.3.22 以前では、<code>ETag</code> の値は
    <em>常に</em>ファイルの inode, サイズ、最終修正時刻 (mtime) から作成
    されていました。<directive>FileETag</directive> ディレクティブにより、これらのどれを使うかを
    選ぶことができます。認識されるキーワードは:
    </p>

    <dl>
     <dt><strong>INode</strong></dt>
     <dd>ファイルの inode 番号を計算に使います</dd>
     <dt><strong>MTime</strong></dt>
     <dd>ファイルの最終修正時刻を使います</dd>
     <dt><strong>Size</strong></dt>
     <dd>ファイルの中身のバイト数を使います</dd>
     <dt><strong>All</strong></dt>
     <dd>使用可能なすべてのフィールドを使います。
     これは <example>FileETag INode MTime Size</example> と等価です。</dd>
     <dt><strong>None</strong></dt>
     <dd>ドキュメントがファイルに基づいたものでも、<code>ETag</code> フィールドを
    応答に付加しません</dd>
    </dl>

    <p><code>INode</code>, <code>MTime</code>, <code>Size</code> キーワードには
    <code>+</code> や <code>-</code> を前に付けて
    指定することもできます。この場合は、より広い範囲から継承された
    デフォルトの設定に変更を加えるようになります。そのような接頭辞の
    無いキーワードを指定すると、即座に継承した設定を無効にします。</p>

    <p>あるディレクトリの設定に
    <code>FileETag&nbsp;INode&nbsp;MTime&nbsp;Size</code> があり、
    サブディレクトリの設定に <code>FileETag&nbsp;-INode</code> があるときは、
    そのサブディレクトリの設定は (設定が上書きされなければサブディレクトリの
    サブディレクトリにも継承されます) <code>FileETag&nbsp;MTime&nbsp;Size</code>
    と同じになります。</p>
    <note type="warning"><title>警告</title>
    WebDAV を使っていて、<module>mod_dav_fs</module> をストレージプロバイダとして
    使っているような Directory や Location では、デフォルト値を変更しないでください。
    <module>mod_dav_fs</module> では、条件付リクエストでの比較演算に
    <code>INode&nbsp;MTime&nbsp;Size</code>
    の固定フォーマットを使っています。
    <directive>FileETag</directive> で <code>ETag</code> フォーマットを
    変更してしまうと、条件付リクエストでうまく動作しなくなります。
    </note>
</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>Files</name>
<description>マッチするファイル名に適用されるディレクティブを囲む</description>
<syntax>&lt;Files <var>filename</var>&gt; ... &lt;/Files&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p><directive type="section">Files</directive> ディレクティブは、
    その中にあるディレクティブの適用範囲をファイル名で制限します。
    <directive module="core"
    type="section">Directory</directive> ディレクティブや <directive
    module="core" type="section">Location</directive> ディレクティブと
    同じような機能を持ちます。
    これは、<code>&lt;/Files&gt;</code> ディレクティブと対に
    なっていなければなりません。
    このセクション中のディレクティブは、ベース名 (ファイル名の最後の部分)
    が指定されたファイル名にマッチするすべてのオブジェクトに適用されます。
    <directive type="section">Files</directive> セクションは
    <directive type="section">Directory</directive> セクションと
    <code>.htaccess</code> が読み込まれた後、
    <directive type="section">Location</directive> セクションよりは先に
    設定ファイルに現れた順に適用されます。
    <directive type="section">Files</directive> は、
    <directive type="section">Directory</directive> セクション内に
    ネストさせることができ、
    ファイルシステムの一部にのみ限定して適用させることができます。</p>

    <p><var>filename</var> 引数は、ファイル名かワイルドカード文字列
    で、ワイルドカードでは <code>?</code> は一つの文字、<code>*</code> は任意の文字列にマッチします。
    <code>~</code> という文字を付加することで<glossary ref="regex">正規表現</glossary>を使うこともできます。
    例えば、</p>

    <example>
      &lt;Files ~ "\.(gif|jpe?g|png)$"&gt;
    </example>

    <p>とすることにより、一般的なインターネットの画像フォーマットにマッチします。
    ただし、
    <directive module="core" type="section">FilesMatch</directive> を使う方が
    推奨されています。</p>

    <p>ちなみに、<directive module="core" type="section"
    >Directory</directive> と <directive module="core" type="section"
    >Location</directive> セクションとは異なり、
    <directive type="section">Files</directive>
    は <code>.htaccess</code> ファイル内で利用することができます。
    これにより、ユーザがファイル毎にアクセスの制御を行なうことができるように
    なっています。</p>

</usage>
<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

<directivesynopsis type="section">
<name>FilesMatch</name>
<description>正規表現にマッチするファイル名に適用される
ディレクティブを囲む</description>
<syntax>&lt;FilesMatch <var>regex</var>&gt; ... &lt;/FilesMatch&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p><directive type="section">FilesMatch</directive> ディレクティブは、
    <directive module="core" type="section">Files</directive>
    ディレクティブ同様にその中にあるディレクティブの適用範囲をファイル名で制限します。ただし、
    このディレクティブには<glossary ref="regex">正規表現</glossary>を指定します。
    例えば:</p>

    <example>
      &lt;FilesMatch "\.(gif|jpe?g|png)$"&gt;
    </example>

    <p>は一般的なインターネットの画像形式にマッチします。</p>
</usage>

<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ForceType</name>
<description>すべてのマッチするファイルが指定の MIME コンテントタイプで
送られるようにする</description>
<syntax>ForceType <var>MIME-type</var>|None</syntax>
<contextlist><context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>
<compatibility>Apache 2.0 で core に移動</compatibility>

<usage>
    <p><code>.htaccess</code> や <directive type="section" module="core"
    >Directory</directive> セクション、
    <directive type="section" module="core">Location</directive> セクション、
    <directive type="section" module="core">Files</directive> セクションに
    書かれた場合、このディレクティブはそこにあるすべてのファイルが
    <var>MIME-type</var>
    で指定されたコンテントタイプとして扱われるようにします。たとえば、
    GIF ファイルばかりのディレクトリがあって、すべてのファイルを <code>.gif</code>
    で終わらせたくはないときに、以下のものを使用します:</p>

    <example>
      ForceType image/gif
    </example>

    <p><directive module="core">DefaultType</directive> と違って
    このディレクティブはメディアタイプを決めることができるかもしれない
    ファイルの拡張子も含め、すべての MIME タイプの関連付けを
    上書きすることに注意してください。</p>

    <p><code>None</code> という値を使うことで <directive>ForceType</directive> の
    設定を無効にできます:</p>

    <example>
      # force all files to be image/gif:<br />
      &lt;Location /images&gt;<br />
        <indent>
          ForceType image/gif<br />
        </indent>
      &lt;/Location&gt;<br />
      <br />
      # but normal mime-type associations here:<br />
      &lt;Location /images/mixed&gt;<br />
      <indent>
        ForceType None<br />
      </indent>
      &lt;/Location&gt;
    </example>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>HostnameLookups</name>
<description>クライアントの IP アドレスの DNS ルックアップを
有効にする</description>
<syntax>HostnameLookups On|Off|Double</syntax>
<default>HostnameLookups Off</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context></contextlist>

<usage>
    <p>このディレクティブは、ホスト名をログ収集できるように
    DNS ルックアップを有効にします
    (さらに、CGI/SSI に <code>REMOTE_HOST</code> 変数として渡します)。
    <code>Double</code>を指定した場合、2 重の逆引きを行ないます。
    つまり、逆引きの後に、その結果に対して正引きを行ないます。正引きの
    結果の IP アドレスの中にオリジナルのアドレスと一致するものがなければ
    なりません。("tcpwrappers" の用語では <code>PARANOID</code> と呼ばれています。)</p>

    <p><module>mod_authz_host</module> でホスト名によるアクセス
    制御を行なう場合には、
    設定の如何によらず 2 重の逆引きが実行されます。
    これは、セキュリティを保つために必要です。
    <code>HostnameLookups Double</code> を設定しない限り、
    他の部分はこの 2 重逆引きの結果を使うことはできません。
    例えば、<code>HostnameLookups On</code> と設定してある状態で、
    ホスト名によるアクセス制限を行なったオブジェクトへの
    リクエストを受けたとすると、2 重の逆引きが成功するか否かによらず、
    <code>REMOTE_HOST</code> には通常の逆引き結果が渡されます。</p>

    <p>ディレクティブのデフォルトは
    本当に逆引きを必要としているわけではないサイトの
    ネットワークトラフィックを低減させるために、<code>Off</code> になっています。
    ルックアップによる余計な遅延がなくなるため、
    エンドユーザにとっても良いでしょう。
    DNS のルックアップには、かなりの時間が必要となる場合が多く、
    負荷の高いサイトではこのディレクティブは <code>Off</code> にすべきです。
    なお、<var>/support</var> ディレクトリに含まれ、デフォルトでは
    インストールディレクトリの <code>bin</code> サブディレクトリに
    インストールされる <program>logresolve</program> ユーティリティにより、
    Apache の動作とは別に、ログに残されている IP アドレスからホスト名を
    ルックアップすることが可能です。</p>
</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>If</name>
<description>実行時、リクエストが条件を満たした場合にのみ適用される
ディレクティブを包含する</description>
<syntax>&lt;If <var>expression</var>&gt; ... &lt;/If&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p><directive type="section">If</directive> ディレクティブは
    実行時に式を評価し、条件式が真になるときにのみ
    内包するディレクティブを適用します。
    例えば</p>

    <example>
        &lt;If "$req{Host} = ''"&gt;
    </example>

    <p>上記例は <var>Host:</var> ヘッダの存在しない HTTP/1.0 のリクエストに
    マッチします。</p>
</usage>

<seealso><a href="../sections.html">どのように &lt;Directory&gt;, &lt;Location&gt;,
    &lt;Files&gt; セクションが動作するか</a> では、リクエストを受けたときに、
    これらの異なるセクションがどのように組み合わさるかについて記載されています。
    <directive type="section">If</directive> は
    <directive type="section">Files</directive>
    と同じ処理順と用法になっています。</seealso>
</directivesynopsis>

<directivesynopsis type="section">
<name>IfDefine</name>
<description>起動時にテストが真であるときのみに処理されるディレクティブを
囲む</description>
<syntax>&lt;IfDefine [!]<var>parameter-name</var>&gt; ...
    &lt;/IfDefine&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p><code>&lt;IfDefine <var>test</var>&gt;...&lt;/IfDefine&gt;</code>
    セクションは、
    ディレクティブを条件付きで指定するために利用します。
    <directive type="section">IfDefine</directive> セクションに
    含まれるディレクティブは、<var>test</var>が
    定義されているときのみ処理されます。
    もし <var>test</var> が定義されていなければ、
    開始と終了の指定の間のディレクティブは無視されます。</p>

    <p><directive type="section">IfDefine</directive> セクションディレクティブに
    指定する <var>test</var> は、
    次の二つの形式のうちの一つをとります:</p>

    <ul>
      <li><var>parameter-name</var></li>

      <li><code>!</code><var>parameter-name</var></li>
    </ul>

    <p>前者の場合には、<var>parameter-name</var> と名付けられたパラメータが
    定義されていれば開始と終了の間のディレクティブが処理されます。
    後者の場合は逆で、<em>parameter-name</em> が指定されて<strong>いない</strong>
    場合に処理されます。</p>

    <p><var>parameter-name</var> 引数は、サーバを起動する際に
    <program>httpd</program> のコマンドラインに
    <code>-D<var>parameter</var></code> という形で指定するか
    あるいは <directive module="core">Define</directive>
    ディレクティブで指定されると定義されます。 </p>

    <p><directive type="section">IfDefine</directive> セクションは
    入れ子にすることができ、複数のパラメータによるテストをするために使用できます。
    例:</p>

    <example>
      httpd -DReverseProxy -DUseCache -DMemCache ...<br />
      <br />
      # httpd.conf<br />
      &lt;IfDefine ReverseProxy&gt;<br />
      <indent>
        LoadModule proxy_module   modules/mod_proxy.so<br />
        LoadModule proxy_http_module   modules/mod_proxy_http.so<br />
        &lt;IfDefine UseCache&gt;<br />
        <indent>
          LoadModule cache_module   modules/mod_cache.so<br />
          &lt;IfDefine MemCache&gt;<br />
          <indent>
            LoadModule mem_cache_module   modules/mod_mem_cache.so<br />
      </indent>
          &lt;/IfDefine&gt;<br />
          &lt;IfDefine !MemCache&gt;<br />
          <indent>
            LoadModule cache_disk_module   modules/mod_cache_disk.so<br />
          </indent>
      &lt;/IfDefine&gt;
        </indent>
        &lt;/IfDefine&gt;
      </indent>
      &lt;/IfDefine&gt;
    </example>
</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>IfModule</name>
<description>モジュールの存在するかしないかに応じて処理される
ディレクティブを囲む</description>
<syntax>&lt;IfModule [!]<var>module-file</var>|<var>module-identifier</var>&gt; ...
    &lt;/IfModule&gt;</syntax>     
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>
<compatibility>モジュール識別子はバージョン 2.1 以降で使用可能。</compatibility>

<usage>
    <p><code>&lt;IfModule <var>test</var>&gt;...&lt;/IfModule&gt;</code>
    セクションは、モジュールが存在するときに処理されるディレクティブを
    指定するために利用します。
    <directive type="section">IfModule</directive> セクションに
    含まれるディレクティブは、<var>test</var>
    で指定するモジュールが組み込まれているときのみ処理されます。
    もし <var>test</var> が組み込まれていなければ、開始と終了の間のディレクティブ
    は無視されます。</p>

    <p><directive type="section">IfModule</directive> セクションディレクティブに
    指定する <var>test</var> は、
    次の二つの形式のうちの一つをとります。</p>

    <ul>
      <li><var>module</var></li>

      <li>!<var>module</var></li>
    </ul>

    <p>前者の場合は、<var>module</var> と名付けられたモジュールが
    Apache に組み込まれていれば
    (コンパイル済みのものと、<directive
    module="mod_so">LoadModule</directive> を利用して
    動的に読み込んだものの両方)、
    開始と終了の間のディレクティブが処理されます。
    後者の場合は逆で、<var>module</var> が組み込まれて<strong>いない</strong>
    場合に処理されます。</p>

    <p><var>module</var> 引数は、モジュール識別子か
    コンパイルをした時のモジュールのファイル名です。
    例えば、<code>rewrite_module</code> は識別子で
    <code>mod_rewrite.c</code> はファイル名です。
    モジュールが複数のソースファイルから構成されている場合は、文字列
    <code>STANDARD20_MODULE_STUFF</code> があるファイルの名前を
    使ってください。</p>

    <p><directive type="section">IfModule</directive> セクションは
    入れ子にすることが可能であり、
    複数のモジュールのテストを行なうために使用できます。</p>

    <note>特定のモジュールの存在に関わらず動作する
    設定ファイルの原本が必要なときにのみこのセクションを使用してください。
    通常の動作では、ディレクティブを
    <directive type="section">IfModule</directive> セクションの中に
    入れる必要はありません。</note>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>Include</name>
<description>サーバ設定ファイル中から他の設定ファイルを取り込む</description>
<syntax>Include <var>file-path</var>|<var>directory-path</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context>
</contextlist>
<compatibility>ワイルドカードによるマッチは 2.0.41 以降で使用可能</compatibility>

<usage>
    <p>このディレクティブにより、サーバの設定ファイルから
    他の設定ファイルをインクルードすることができます。</p>

    <p>複数のファイルをアルファベット順に一度に読み込むために、
    シェル形式 (<code>fnmatch</code>) のワイルドカード文字を使うことができます。
    さらに、<directive>Include</directive> にディレクトリを指定した場合は、
    ディレクトリとそのサブディレクトリ内の全てのファイルを
    アルファベット順に読み込んで、設定ファイルとして処理します。
    しかし、ディレクトリ全体を読み込むのはお勧めできません。
    ふとしたことから <code>httpd</code> が読み込みに失敗するような
    一時ファイルをディレクトリに残してしまうようなことがよくあるからです。</p>

    <p>指定するファイルパスは絶対パスか、
    <directive module="core">ServerRoot</directive> ディレクトリからの
    相対パスか、のどちらかです。</p>

    <p>例:</p>

    <example>
      Include /usr/local/apache2/conf/ssl.conf<br />
      Include /usr/local/apache2/conf/vhosts/*.conf
    </example>

     <p><directive module="core">ServerRoot</directive> からの相対パスの場合は:</p>

    <example>
      Include conf/ssl.conf<br />
      Include conf/vhosts/*.conf
    </example>
</usage>

<seealso><program>apachectl</program></seealso>
</directivesynopsis>

<directivesynopsis>
<name>KeepAlive</name>
<description>HTTP の持続的な接続を有効にする</description>
<syntax>KeepAlive On|Off</syntax>
<default>KeepAlive On</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p>HTTP/1.0 の Keep-Alive 拡張と HTTP/1.1 の持続的接続の機能は、
    複数のリクエストが同じ TCP の接続で送られる、長時間持続する
    HTTP セッションを提供します。たくさんの画像が
    含まれる HTML ドキュメントでは場合によっては遅延時間が 50% 短縮される結果も
    でています。Keep-Alive 接続を有効にするには
    <code>KeepAlive On</code> と設定します。</p>

    <p>HTTP/1.0 に対応したクライアントの際には、
    クライアントより特に要求があった場合のみ Keep-Alive 接続となります。
    さらに、HTTP/1.0 クライアントでは、コンテンツの容量が先に
    (訳注: 要求に対して応答を返す前に) わかる場合のみ Keep-Alive
    接続を利用できます。
    これは、CGI の出力や SSI のページ、
    サーバが生成したディレクトリのリストのような動的コンテンツを
    HTTP/1.0 クライアントに送る場合には Keep-Alive 接続を使えないことを意味します。
    HTTP/1.1 に対応したクライアントの際には、
    特に指定されない限りはデフォルトとして持続的な接続が行なわれます。
    クライアントが要求すれば、コンテンツの容量を判別できないものを
    持続的な接続を通して送るために、チャンクエンコーディングが用いられます。</p>

    <p>クライアントが Keep-Alive コネクションを使用している場合、
    そのコネクションを通してどれだけたくさんのリクエストが処理されても、
    それは「リクエスト」1 つとして、MaxRequestsPerChild ディレクティブでは
    数えられます。</p>
</usage>

<seealso><directive module="core">MaxKeepAliveRequests</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>KeepAliveTimeout</name>
<description>持続的な接続で次のリクエストが来るまでサーバが待つ時間</description>
<syntax>KeepAliveTimeout <var>seconds</var></syntax>
<default>KeepAliveTimeout 5</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p>接続を閉じる前に、Apache が次のリクエストを何秒待つかを指定します。
    リクエストを受け付けた後は、<directive
    module="core">Timeout</directive> ディレクティブによって
    指定されたタイムアウト値が使われます。</p>

    <p><directive>KeepAliveTimeout</directive> を大きな値に設定すると、
    負荷の高いサーバにおいてはパフォーマンスの問題を引き起こす場合があります。
    タイムアウトが長ければ長いほど、より多くのサーバプロセスが
    活性でないクライアントからの接続の終了を待ち続けることになります。</p>
    
    <p>名前ベースのバーチャルホストコンテキストでは、
    <directive module="core">NameVirtualHost</directive>
    のセットの中で最初に定義されたバーチャルホストの値
    (デフォルトホスト) が使われます。
    その他の値は無視されます。</p>
</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>Limit</name>
<description>囲いの中にあるアクセス制御の適用を特定の HTTP メソッドのみに
制限する</description>    
<syntax>&lt;Limit <var>method</var> [<var>method</var>] ... &gt; ...
    &lt;/Limit&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p>アクセス制御は、通常<strong>全ての</strong>アクセスメソッドに対して
    影響し、普通はこれが望ましい挙動です。
    <strong>そうしたことから、大部分の場合にはアクセス制御に関わるディレクティブを
    <directive type="section">Limit</directive> セクション内に
    書くべきではありません。 </strong></p>

    <p><directive type="section">Limit</directive> ディレクティブの
    目的は、アクセス制御の範囲を
    指定された HTTP メソッドに限定するためです。
    それ以外のメソッドは、<directive type="section">Limit</directive> で囲われたアクセス制御の
    <strong>影響を受けません</strong>。
    以下の例は、<code>POST</code>, <code>PUT</code>, <code>DELETE</code> のメソッドに対してのみアクセスの制御を行ない、
    それ以外のメソッドについては制限しません:</p>

    <example>
      &lt;Limit POST PUT DELETE&gt;<br />
      <indent>
        Require valid-user<br />
      </indent>
      &lt;/Limit&gt;
    </example>

    <p>メソッド名には以下の中から一つ以上を列挙することができます:
    <code>GET</code>,
    <code>POST</code>, <code>PUT</code>, <code>DELETE</code>,
    <code>CONNECT</code>, <code>OPTIONS</code>,
    <code>PATCH</code>, <code>PROPFIND</code>, <code>PROPPATCH</code>,
    <code>MKCOL</code>, <code>COPY</code>, <code>MOVE</code>,
    <code>LOCK</code>, <code>UNLOCK</code>. <strong>メソッド名は
    大文字小文字を区別します。</strong> <code>GET</code> を指定した場合には
    <code>HEAD</code> リクエストにも制限がかかります。<code>TRACE</code>
    メソッドに制限をかけることはできません
    (<directive type="section" module="core">TraceEnable</directive> 参照)。</p>

    <note type="warning">アクセス制御が目的の場合は
    <directive type="section" module="core">Limit</directive> 
    セクションの代わりに <directive type="section" 
    module="core">LimitExcept</directive> セクションを使用した方が良いでしょう。
    <directive type="section" module="core">LimitExcept</directive>
    セクションでは不特定のメソッドに対しても防御できるからです。</note>

</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>LimitExcept</name>
<description>指定されたもの以外の HTTP メソッドにアクセス制御を
制限する</description>
<syntax>&lt;LimitExcept <var>method</var> [<var>method</var>] ... &gt; ...
    &lt;/LimitExcept&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p><directive type="section">LimitExcept</directive> と
    <code>&lt;/LimitExcept&gt;</code> は、引数に
    <strong>含まれていない</strong>
    HTTP のアクセスメソッドに適用するためのアクセス制御
    ディレクティブを括るために利用します。
    つまり、<directive type="section" module="core"
    >Limit</directive> セクションの反対の動作をし、
    標準のメソッドと標準外や未認識のメソッドの場合の両方を設定できます。
    <directive type="section" module="core">Limit</directive> のドキュメントも
    併せて参照してください。</p>

    <p>例:</p>

    <example>
      &lt;LimitExcept POST GET&gt;<br />
      <indent>
        Require valid-user<br />
      </indent>
      &lt;/LimitExcept&gt;
    </example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>LimitInternalRecursion</name>
<description>内部リダイレクトと入れ子になったサブリクエストの最大数を決定する</description>
<syntax>LimitInternalRecursion <var>number</var> [<var>number</var>]</syntax>
<default>LimitInternalRecursion 10</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>
<compatibility>Apache 2.0.47 以降で使用可能</compatibility>

<usage>
    <p>内部リダイレクトは例えば <directive>Action</directive> ディレクティブを
    使っているときに起こります。<directive>Action</directive> ディレクティブは
    元々のリクエストを CGI スクリプトに内部リダイレクトを行ないます。
    サブリクエストはいくつかの URI に対して、リクエストされたときに
    何が起こるかを調べるための Apache の機構です。例えば、<module>mod_dir</module>
    は <directive module="mod_dir">DirectoryIndex</directive> ディレクティブ
    がリストするファイルを調べるためにサブリクエストを使います。</p>

    <p><directive>LimitInternalRecursion</directive> は内部リダイレクトや
    サブリクエストが無限ループに陥ったときのサーバクラッシュを防ぎます。
    普通、そのようなループは設定に失敗したときに発生します。</p>

    <p>このディレクティブは、リクエスト毎に評価される、二つの違う限界値を
    設定します。最初の <var>number</var> は、起こり得る
    内部リクエストの最大値を設定します。二つめの <var>number</var> は
    サブリクエストが入れ子にできる深さを設定します。<var>number</var> を
    一つだけ指定したときは、両方の限界値にその値が設定されます。</p>

    <example><title>例</title>
      LimitInternalRecursion 5
    </example>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>LimitRequestBody</name>
<description>クライアントから送られる HTTP リクエストのボディの
総量を制限する</description>
<syntax>LimitRequestBody <var>bytes</var></syntax>
<default>LimitRequestBody 0</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p>このディレクティブは、リクエストボディに許されるバイト数、<var>bytes</var>
    を 0 (無制限を意味します) から 2147483647 (2GB) までの数値で指定します。</p>

    <p><directive>LimitRequestBody</directive> ディレクティブは、
    ディレクティブが書かれたコンテキスト
    (サーバ全体、ディレクトリ、ファイル、ロケーション) 内で
    許容する  HTTP リクエストメッセージボディのサイズに制限をかけることができます。
    クライアントのリクエストがその制限値を越えていれば、
    サーバはリクエストを処理せずにエラーを返します。
    普通のリクエストメッセージボディのサイズは、リソースの種類や
    許可されているメソッドによって大きく変わります。
    CGI スクリプトは、よく情報を受信するために
    メッセージボディを使います。
    <code>PUT</code> メソッドの実装は、このディレクティブの値として
    少なくともあるリソースに対してサーバが受け付けようとする
    表現の大きさほどの値を必要とします。</p>

    <p>このディレクティブは、
    管理者にクライアントからの異常なリクエストを制御できるようにし、
    何らかの形のサービス拒否攻撃 (訳注:DoS) を避けるのに有効です。</p>

    <p>ある場所へのファイルアップロードを許可する場合に、
    アップロードできるファイルのサイズを 100K に制限したければ、
    以下のように指定します:</p>

    <example>
      LimitRequestBody 102400
    </example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>LimitRequestFields</name>
<description>クライアントからの HTTP リクエストのヘッダフィールドの数を
制限する</description>
<syntax>LimitRequestFields <var>number</var></syntax>
<default>LimitRequestFields 100</default>
<contextlist><context>server config</context></contextlist>

<usage>
    <p><var>number</var> には、0 (無制限を意味します) から 32767
    までの整数を指定します。
    デフォルト値は、定数 <code>DEFAULT_LIMIT_REQUEST_FIELDS</code>
    によりコンパイル時に定義されます (配布時には 100 と指定されています)。</p>

    <p><directive>LimitRequestBody</directive> ディレクティブは、
    サーバ管理者が HTTP リクエスト中において許可するリクエストヘッダフィールド数を
    指定します。
    サーバはこの値には通常のクライアントからのリクエストに含まれるであろう
    フィールドの数より大きな値が必要とします。
    クライアントにより使われた要求ヘッダーフィールドの数が
    20 を超えることはほとんどありませんが、
    これは種々のクライアントの実装によって変わり、
    詳細なコンテントネゴシエーションをするためのブラウザの設定までにも
    影響されることがあります。
    オプションの HTTP 拡張はリクエストヘッダフィールドを使って表される場合が
    多くあります。</p>

    <p>このディレクティブは、
    管理者にクライアントからの異常なリクエストを制御できるようにし、
    何らかの形のサービス拒否攻撃 (訳注:DoS) を避けるのに有効です。
    リクエストのフィールドが多過ぎることを意味するエラー応答が
    普通のクライアントに返されるような時はこの値を増やしてください。</p>

    <p>例:</p>

    <example>
      LimitRequestFields 50
    </example>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>LimitRequestFieldSize</name>
<description>クライアントからの HTTP リクエストのヘッダの
サイズを制限する</description>
<syntax>LimitRequestFieldSize <var>bytes</var></syntax>
<default>LimitRequestFieldSize 8190</default>
<contextlist><context>server config</context></contextlist>

<usage>
    <p>このディレクティブは、HTTP リクエストヘッダ一つで受付ける
    バイト数 <var>bytes</var> を指定します。</p>

    <p><directive>LimitRequestFieldSize</directive> ディレクティブは、
    HTTP リクエストヘッダで許容されるサイズを増減させることができます。
    サーバは、このディレクティブの値として、
    一般的なクライアントからリクエストが送られた際に、そのリクエストに
    付属しているどのヘッダフィールドについても、
    十分足りる大きさになっていなければなりません。
    一般的なリクエストヘッダのサイズといっても、その大きさは個々の
    クライアントの実装によって大きく異なり、
    詳細なコンテントネゴシエーションをサポートするかどうかの、
    ブラウザの設定にも影響されたりします。
    SPNEGO 認証ヘッダでは 12392 バイトにまで及ぶことすらあります。</p>

    <p>このディレクティブは、
    管理者にクライアントからの異常なリクエストを制御できるようにし、
    何らかの形のサービス拒否攻撃 (訳注:DoS) を避けるのに有効です。</p>

    <p>例:</p>

    <example>
      LimitRequestFieldSize 4094
    </example>

    <note>通常はデフォルトから変更する必要はありません。</note>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>LimitRequestLine</name>
<description>クライアントからの HTTP リクエスト行のサイズを制限する</description>
<syntax>LimitRequestLine <var>bytes</var></syntax>
<default>LimitRequestLine 8190</default>
<contextlist><context>server config</context></contextlist>

<usage>
    <p>このディレクティブは、HTTP リクエスト行内で許容されるバイト数
    <var>bytes</var> を指定します。</p>

    <p><directive>LimitRequestLine</directive> ディレクティブにより、
    クライアントからの HTTP リクエスト行の許容サイズを増減できます。 
    リクエスト行は、HTTPメソッド、URI、プロトコルバージョンから成っており、
    <directive>LimitRequestLine</directive> はサーバへのリクエストに対して
    許容するリクエスト URI の長さを制限することになります。
    サーバは、<code>GET</code> リクエストのクエリ部分も含めて、リソースの名前が入るに足る
    大きさを必要とします。</p>

    <p>このディレクティブは、
    管理者にクライアントからの異常なリクエストを制御できるようにし、
    何らかの形のサービス拒否攻撃 (訳注:DoS) を避けるのに有効です。</p>

    <p>例:</p>

    <example>
      LimitRequestLine 4094
    </example>

    <note>通常はデフォルトから変更する必要はありません。</note>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>LimitXMLRequestBody</name>
<description>XML 形式のリクエストのボディのサイズを制限する</description>
<syntax>LimitXMLRequestBody <var>bytes</var></syntax>
<default>LimitXMLRequestBody 1000000</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>All</override>

<usage>
    <p>XML 形式のリクエストのボディの最大値を (バイト単位で) 制限します。
    値に <code>0</code> を指定するとチェックを無効にします。</p>

    <p>例:</p>

    <example>
    LimitXMLRequestBody 0
    </example>

</usage>
</directivesynopsis>

<directivesynopsis type="section">
<name>Location</name>
<description>囲んだディレクティブをマッチする URL のみに適用</description>
<syntax>&lt;Location
    <var>URL-path</var>|<var>URL</var>&gt; ... &lt;/Location&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive type="section">Location</directive> ディレクティブは、
    URL により中に書かれたディレクティブの適用範囲を制限します。
    <directive type="section" module="core">Directory</directive>
    ディレクティブと似ていて、
    <code>&lt;/Location&gt;</code> ディレクティブで終了する
    サブセクションを開始します。
    <directive type="section">Location</directive> セクションは、
    <directive type="section" module="core">Directory</directive> セクションと
    <code>.htaccess</code> の読み込みの後、
    <directive type="section" module="core">Files</directive> セクションを
    適用した後に、設定ファイルに現れた順に処理されます。</p>

    <p><directive type="section">Location</directive> セクションは
    完全にファイルシステムと関連せずに動作します。このことから導かれる
    結果にはいくつか注意する点があります。最も重要なものは、
    ファイルシステムの位置へのアクセス制御に <directive
    type="section">Location</directive> ディレクティブを使うべきではない
    ということです。複数の URL がファイルシステムの同じ位置にマップされる
    可能がありますので、そのようなアクセス制御は回避されてしまう可能性が
    あります。</p>

    <note><title>いつ <directive 
    type="section">Location</directive> を使うか</title>

    <p><directive type="section">Location</directive> ディレクティブは
    ファイルシステム外のコンテンツにディレクティブを適用するときに
    使用してください。ファイルシステムに存在するコンテンツに対しては、
    <directive
    type="section" module="core">Directory</directive> と <directive
    type="section" module="core">Files</directive> を使ってください。
    例外は、<code>&lt;Location /&gt;</code> で、これはサーバ全体に対して
    設定を適用する簡単な方法です。</p>
    </note>

    <p>全ての (プロキシ以外の) リクエストに対し、
    URL は <code>/path/</code> という、
    接頭辞 <code>http://servername</code> を含まない形でマッチします。
    プロキシリクエストの場合には、<code>scheme://servername/path</code>
    という接頭辞を含む形でマッチし、接頭辞を含めて指定する必要があります。</p>

    <p>URL にはワイルドカードを利用することができます。
    <code>?</code> は任意の一文字、<code>*</code> は任意の文字列にマッチします。
    どちらのワイルドカードも URL パス中の / にはマッチしません。</p>

    <p><code>~</code> という文字を追加することで、<glossary ref="regex">正規表現</glossary>を
    利用することもできます。
    例えば:</p>

    <example>
      &lt;Location ~ "/(extra|special)/data"&gt;
    </example>

    <p>は URL に <code>/extra/data</code> か <code>/special/data</code> という文字列が
    含まれている場合にマッチします。
   <directive type="section" module="core"
    >LocationMatch</directive> ディレクティブは
    <directive type="section">Location</directive> の正規表現
    版とまったく同じ動作をします。</p>

    <p><directive type="section">Location</directive> 機能は、<directive
    module="core">SetHandler</directive> ディレクティブと
    組合わせて利用すると特に便利です。
    例えば、<code>example.com</code> のブラウザからのみステータスの参照を有効にしたければ、
    次のようにすれば良いでしょう。</p>

    <example>
      &lt;Location /status&gt;<br />
      <indent>
        SetHandler server-status<br />
        Order Deny,Allow<br />
        Deny from all<br />
        Allow from .example.com<br />
      </indent>
      &lt;/Location&gt;
    </example>

<note><title>/ (スラッシュ) に関する注</title>
    <p>スラッシュ文字は、URL 内に現れる場所に応じて変化する
    特別な意味を持っています。
    ファイルシステムにおいて利用する場合には複数のスラッシュでも一つの
    スラッシュとして扱われることが多いですが、
    (<em>すなわち</em>、<code>/home///foo</code> は
    <code>/home/foo</code> と同じといったように)
    URL においては必ずしもそうなるわけではありません。
    <directive type="section" module="core">LocationMatch</directive>
    ディレクティブや正規表現を利用した
    <directive type="section">Location</directive> ディレクティブで、
    複数のスラッシュにマッチさせたいときには、明示的に記述する
    必要があります。</p>

    <p>例えば、<code>&lt;LocationMatch ^/abc&gt;</code> は、
    <code>/abc</code> というリクエスト URL にマッチしますが、
    <code>//abc</code> というリクエスト URL にはマッチしません。
    (正規表現でない) <directive type="section">Location</directive>
    ディレクティブは、
    proxy リクエストに対して利用する際には同様の振る舞いをしますが、
    (正規表現でない) <directive type="section">Location</directive> を proxy
    でないリクエストに対して利用する際には、
    一つのスラッシュで複数のスラッシュにマッチします。
    例えば、<code>&lt;Location /abc/def&gt;</code> と指定し、
    <code>/abc//def</code> というリクエストがあれば、
    マッチすることになります。</p></note>

</usage>
<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

<directivesynopsis type="section">
<name>LocationMatch</name>
<description>囲んだディレクティブを正規表現にマッチする URL のみに
適用</description>
<syntax>&lt;LocationMatch
    <var>regex</var>&gt; ... &lt;/LocationMatch&gt;</syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive type="section">LocationMatch</directive> ディレクティブは、
    <directive type="section" module="core">Location</directive> と同じ様に
    URL により中に書かれたディレクティブの適用範囲を制限します。
    但し、引数は普通の文字列ではなく、<glossary ref="regex">正規表現</glossary>となります。
    例えば、</p>

    <example>
      &lt;LocationMatch "/(extra|special)/data"&gt;
    </example>

    <p>は URL に <code>/extra/data</code> か <code>/special/data</code>
    という文字列が含まれている場合にマッチします。</p>
</usage>

<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>LogLevel</name>
<description>ErrorLog の冗長性を制御する</description>
<syntax>LogLevel <var>level</var></syntax>
<default>LogLevel warn</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive>LogLevel</directive> は、エラーログ (<directive module="core"
    >ErrorLog</directive> ディレクティブを
    見てください) へ記録するメッセージの冗長性を調整します。
    以下の <var>level</var> を指定でき、順に重要度が下がっていきます。</p>

    <table border="1">
      <tr>
        <th><strong>レベル</strong> </th>

        <th><strong>説明</strong> </th>

        <th><strong>例</strong> </th>
      </tr>

      <tr>
        <td><code>emerg</code> </td>

        <td>緊急 - システムが利用できない</td>

        <td>Child cannot open lock file. Exiting 
        (子プロセスがロックファイルを開けないため終了した)</td>
      </tr>

      <tr>
        <td><code>alert</code> </td>

        <td>直ちに対処が必要</td>

        <td>getpwuid: couldn't determine user name from uid
        (getpwuid: UID からユーザ名を特定できなかった)</td>
      </tr>

      <tr>
        <td><code>crit</code> </td>

        <td>致命的な状態</td>

        <td>socket: Failed to get a socket, exiting child
        (socket: ソケットが得られないため、子プロセスを終了させた)</td>
      </tr>

      <tr>
        <td><code>error</code> </td>

        <td>エラー</td>

        <td>Premature end of script headers
        (スクリプトのヘッダが足りないままで終わった)</td>
      </tr>

      <tr>
        <td><code>warn</code> </td>

        <td>警告</td>

        <td>child process 1234 did not exit, sending another SIGHUP
        (子プロセス 1234 が終了しなかった。もう一度 SIGHUP を送る)</td>
      </tr>

      <tr>
        <td><code>notice</code> </td>

        <td>普通だが、重要な情報</td>

        <td>httpd: caught SIGBUS, attempting to dump core in ...
        (httpd: SIGBUS シグナルを受け、... へコアダンプをした)</td>
      </tr>

      <tr>
        <td><code>info</code> </td>

        <td>追加情報</td>

        <td>"Server seems busy, (you may need to increase
        StartServers, or Min/MaxSpareServers)..." (「サーバは負荷が高い、
        (StartServers や Min/MaxSpareServers の値を増やす必要があるかも)」)</td>
      </tr>

      <tr>
        <td><code>debug</code> </td>

        <td>デバッグメッセージ</td>

        <td>"Opening config file ..." (設定ファイルを開いている...)</td>
      </tr>
    </table>

    <p>特定のレベルが指定された場合、それより高いレベルの全てのメッセージが
    報告されます。
    <em>例えば</em>、<code>LogLevel info</code> に指定すると、
    <code>notice</code> と <code>warn</code> も報告されます。</p>

    <p>なお <code>crit</code> 以上のレベルを指定することが推奨されます。</p>

    <p>例:</p>

    <example>
      LogLevel notice
    </example>

    <note><title>注</title>
      <p>ファイルにログを出力する場合、<code>notice</code>
      レベルのメッセージは抑制されず、すべてログに出力されます。
      しかし <code>syslog</code> を使用している場合は、
      これは当てはまりません。</p>
    </note>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>MaxKeepAliveRequests</name>
<description>持続的な接続上で許可されるリクエストの数</description>
<syntax>MaxKeepAliveRequests <var>number</var></syntax>
<default>MaxKeepAliveRequests 100</default>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive>MaxKeepAliveRequests</directive> ディレクティブは、
    <directive module="core">KeepAlive</directive> が有効な場合に、
    一回の接続で受け付け可能なリクエストの数を制限します。
    <code>0</code> に設定していれば、受け付けるリクエストは無制限になります。
    この設定は、サーバ性能を向上させるために、大きな数値を指定することを勧めます。
    </p>

    <p>例:</p>

    <example>
      MaxKeepAliveRequests 500
    </example>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>NameVirtualHost</name>
<description>名前ベースのバーチャルホストのための IP アドレスを指定</description>
<syntax>NameVirtualHost <var>addr</var>[:<var>port</var>]</syntax>
<contextlist><context>server config</context></contextlist>

<usage>
    <p><directive>NameVirtualHost</directive> ディレクティブは、
    <a href="../vhosts/">名前ベースのバーチャルホスト</a>の設定を行ないたい場合に
    必要となるものです。</p>

    <p><var>addr</var> にはホスト名を指定できますが、
    常に IP アドレスを指定するのが推奨されます。
    例えば、</p>

    <example>
      NameVirtualHost 111.22.33.44
    </example>

    <p><directive>NameVirtualHost</directive> ディレクティブは、
    名前ベースのバーチャルホストを
    利用してリクエストを受け付ける IP アドレスを指定します。
    これは、普通は名前ベースのバーチャルホストアドレスです。
    ただし、ファイアーウォールや他のプロキシがリクエストを受け付け、
    違う IP アドレスのサーバにフォワードするという場合は、
    リクエストを提供したいマシン上の物理インターフェースの
    IP アドレスを指定する必要があります。
    複数のアドレスで複数の名前ベースのバーチャルホストを指定する場合は
    各アドレスに対してディレクティブを書いてください。</p>

    <note><title>中</title>
      <p>「主サーバ」や、どの <code>_default_</code> サーバも、
      <directive>NameVirtualHost</directive> で指定した IP アドレスへのリクエスト
      を処理することは<strong>ありません</strong> (なぜか
      <directive>NameVirtualHost</directive> を
      指定したけどそのアドレスに <directive>VirtualHost</directive> を定義しなかった場合を除く)。</p>
    </note>

    <p>名前ベースのバーチャルホストにポート番号を指定することも可能です。
    例えば</p>

    <example>
      NameVirtualHost 111.22.33.44:8080
    </example>

    <p>IPV6 のアドレスは次の例のように角括弧で囲む必要があります:</p>
 
    <example>
      NameVirtualHost [2001:db8::a00:20ff:fea7:ccea]:8080
    </example>

    <p>すべてのインタフェースへのリクエストを受け取るようにするためには、
    引数として <code>*</code> を使います。</p>

    <example>
      NameVirtualHost *
    </example>

    <note><title><directive type="section">VirtualHost</directive> ディレクティブの引数</title>
      <p><directive type="section">VirtualHost</directive> ディレクティブの引数は <directive
      >NameVirtualHost</directive> ディレクティブの引数に正確に
      合っている必要があることに注意してください。</p>

      <example>
        NameVirtualHost 1.2.3.4<br />
        &lt;VirtualHost 1.2.3.4&gt;<br />
        # ...<br />
        &lt;/VirtualHost&gt;<br />
      </example>
    </note>

</usage>

<seealso><a href="../vhosts/">バーチャルホスト説明書
</a></seealso>

</directivesynopsis>

<directivesynopsis>
<name>Options</name>
<description>ディレクトリに対して使用可能な機能を設定する</description>
<syntax>Options
    [+|-]<var>option</var> [[+|-]<var>option</var>] ...</syntax>
<default>Options All</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>Options</override>

<usage>
    <p><directive>Options</directive> ディレクティブは、特定のディレクトリに対して
    どの機能が使用可能かを制御します。</p>

    <p><var>option</var> を <code>None</code>に指定すると、
    特別な機能は全て無効になります。
    また、以下の示す 1 個以上のものを指定できます。</p>

    <dl>
      <dt><code>All</code></dt>

      <dd><code>MultiViews</code> を除いた全ての機能が有効となります。
      これがデフォルトです。</dd>

      <dt><code>ExecCGI</code></dt>

      <dd>
      <module>mod_cgi</module> による CGI スクリプトの実行を許可します。</dd>

      <dt><code>FollowSymLinks</code></dt>

      <dd>
      サーバが、このディレクトリ内でシンボリックリンクをたどれるようにします。
      <note><p>サーバがシンボリックリンクをたどる場合でも、
      <directive type="section" module="core">Directory</directive> セクションに
      マッチさせるための
      パス名は<em>変更されません</em>。</p>
      <p><directive type="section" module="core">Location</directive> 内に
      このオプションを指定しても<strong>無視される</strong>ことに
      注意してください。</p>
      <p>このオプションを省略したからといってセキュリティの強化にはなりません。
      なぜなら symlink の検査はレースコンディションを引き起こす可能性があり、
      そのため回避可能になるからです。</p>
      </note></dd>

      <dt><code>Includes</code></dt>

      <dd>
      <module>mod_include</module> が提供する SSI を有効にします。</dd>

      <dt><code>IncludesNOEXEC</code></dt>

      <dd>
      SSI は有効になりますが、<code>#exec</code> コマンド と <code>#exec CGI</code> は無効になります。
      ただし、<code>#include virtual</code> により、<directive module="mod_alias">ScriptAlias</directive> されたディレクトリで
      CGI を実行することは可能です。</dd>

      <dt><code>Indexes</code></dt>

      <dd>
      もし、URL がディレクトリにマップするリクエストであって、
      且つ <directive module="mod_dir">DirectoryIndex</directive> で指定したファイル (例えば、<code>index.html</code>) が
      ディレクトリ内に無ければ、<module>mod_autoindex</module> が
      ディレクトリ内の一覧を整形して返します。</dd>

      <dt><code>MultiViews</code></dt>

      <dd>
      <module>mod_negotiation</module> による
      <a href="../content-negotiation.html">コンテントネゴシエーション</a> 
      された "MultiViews" を許可します。</dd>

      <dt><code>SymLinksIfOwnerMatch</code></dt>

      <dd>
      シンボリック先のファイルまたはディレクトリが、
      シンボリックリンクの所有ユーザ ID と同じ場合にのみシンボリックリンクを
      たどれるようにします。

      <note><title>注</title> <p><directive type="section" module="core"
      >Location</directive> 内にこのオプションを
      指定しても無視されます。</p>
      <p>このオプションはセキュリティの強化にはなりません。
      なぜなら symlink の検査はレースコンディションを引き起こす可能性があり、
      そのため回避可能になるからです。</p>
      </note>
      </dd>
    </dl>

    <p>通常、ディレクトリに対して複数の <directive>Options</directive> が
    適用可能な場合、
    最も近いもの一つのみが適用され、他のものは無視されます。
    複数の指定がマージされるわけではありません。(<a
    href="../sections.html#mergin">セクションのマージ方法</a>を参照してください。)
    しかし、すべての <directive>Options</directive> ディレクティブが <code>+</code> や <code>-</code> 付きで
    指定された場合はオプションの値はマージされます。
    <code>+</code> を頭につければ現在の設定に加えられ、
    <code>-</code> を付ければ現在の設定から削除されます。</p>

    <note type="warning"><title>警告</title>
    <p><directive>Options</directive> で <code>+</code> や
    <code>-</code> のついたものを、つけないものと組み合わせて
    指定する構文は正しい構文ではありませんので、期待する結果に
    ならないことがあります。</p>
    </note>

    <p>例えば、<code>+</code> や <code>-</code> を利用しない場合は:</p>

    <example>
      &lt;Directory /web/docs&gt;<br />
      <indent>
        Options Indexes FollowSymLinks<br />
      </indent>
      &lt;/Directory&gt;<br />
      <br />
      &lt;Directory /web/docs/spec&gt;<br />
      <indent>
        Options Includes<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p><code>/web/docs/spec</code> というディレクトリには、
    <code>Includes</code> だけが適用されます。
    しかし、2 番目の <directive>Options</directive> で <code>+</code> や <code>-</code> を利用してみると:</p>
 
    <example>
      &lt;Directory /web/docs&gt;<br />
      <indent>
        Options Indexes FollowSymLinks<br />
      </indent>
      &lt;/Directory&gt;<br />
      <br />
      &lt;Directory /web/docs/spec&gt;<br />
      <indent>
        Options +Includes -Indexes<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p><code>/web/docs/spec</code> というディレクトリには、 <code>FollowSymLinks</code> と
    <code>Includes</code> が適用されます。</p>

    <note><title>注</title>
      <p><code>-IncludesNOEXEC</code> もしくは
      <code>-Includes</code> を指定すると、
      前の設定がどのようになっていようとも SSI は無効となります。</p>
    </note>

    <p>どのような設定もされていなければ、デフォルトでは <code>All</code> に
    なります。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>RLimitCPU</name>
<description>Apache の子プロセスから起動されたプロセスの CPU 消費量を
制限する</description>
<syntax>RLimitCPU <var>seconds</var>|max [<var>seconds</var>|max]</syntax>
<default>未設定。オペレーティングシステムのデフォルトを使用</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>All</override>

<usage>
    <p>一つか二つのパラメータをとります。
    最初のパラメータは全プロセスに対するリソースのソフトリミットを設定し、
    2 番目のパラメータは最大のリソースリミットを設定します。
    パラメータには数字か、オペレーティングシステムの最大となる
    <code>max</code> のどちらかを指定することができます。
    最大のリソースリミットを上げるためには、サーバを
    <code>root</code> で実行するか起動されなければいけません。</p>

    <p>ちなみに、この設定は Apache の子プロセス自体ではなく、
    リクエストを受け付けた Apache の子プロセスから fork されたプロセスに
    適用されます。
    これには CGI や SSI から実行されたコマンドが含まれますが、Apache の
    親プロセスから fork されたログのパイププロセスなどには適用されません。</p>

    <p>CPU リソースのリミットはプロセスあたりの秒数で表わされます。</p>

</usage>
<seealso><directive module="core">RLimitMEM</directive></seealso>
<seealso><directive module="core">RLimitNPROC</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>RLimitMEM</name>
<description>Apache の子プロセスから起動されたプロセスのメモリ消費量を
制限する</description>
<syntax>RLimitMEM <var>bytes</var>|max [<var>bytes</var>|max]</syntax>
<default>未設定。オペレーティングシステムのデフォルトを使用</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>All</override>

<usage>
    <p>一つか二つのパラメータをとります。
    最初のパラメータは全プロセスに対するリソースのソフトリミットを設定し、
    2 番目のパラメータは最大のリソースリミットを設定します。
    パラメータには数字か、オペレーティングシステムの最大となる
    <code>max</code> のどちらかを指定することができます。
    最大のリソースリミットを上げるためには、サーバを
    <code>root</code> で実行するか起動されなければいけません。</p>

    <p>この設定は Apache の子プロセス自体ではなく、
    リクエストを受け付けた Apache の子プロセスから fork されたプロセスに
    適用されます。
    これには CGI や SSI から実行されたコマンドが含まれますが、Apache の
    親プロセスから fork されたログのパイププロセスなどには適用されません。</p>

    <p>メモリリソースのリミットはプロセスあたりのバイト数で表わされます。</p>
</usage>
<seealso><directive module="core">RLimitCPU</directive></seealso>
<seealso><directive module="core">RLimitNPROC</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>RLimitNPROC</name>
<description>Apache の子プロセスから起動されたプロセスが起動するプロセスの
数を制限する</description>
<syntax>RLimitNPROC <var>number</var>|max [<var>number</var>|max]</syntax>
<default>未設定。オペレーティングシステムのデフォルトを使用</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>All</override>

<usage>
    <p>一つか二つのパラメータをとります。
    最初のパラメータは全プロセスに対するリソースのソフトリミットを設定し、
    2 番目のパラメータは最大のリソースリミットを設定します。
    パラメータには数字か、オペレーティングシステムの最大となる
    <code>max</code> のどちらかを指定することができます。
    最大のリソースリミットを上げるためには、サーバを
    <code>root</code> で実行するか起動されなければいけません。</p>

    <p>この設定は Apache の子プロセス自体ではなく、
    リクエストを受け付けた Apache の子プロセスから fork されたプロセスに
    適用されます。
    これには CGI や SSI から実行されたコマンドが含まれますが、Apache の
    親プロセスから fork されたログのパイププロセスなどには適用されません。</p>

    <p>プロセスの制限は、ユーザあたりのプロセス数で制御されます。</p>

    <note><title>注</title>
      <p> CGI プロセスがウェブサーバのユーザ ID 以外で実行されるので
      <strong>無ければ</strong>、
      このディレクティブは、サーバ自身が生成できるプロセスの数を制限することになります。
      そのような状況になっているかどうかは、<code>error_log</code> 中の
      <strong><code>cannot fork</code></strong> というメッセージにより
      確認することができます。</p>
    </note>
</usage>
<seealso><directive module="core">RLimitMEM</directive></seealso>
<seealso><directive module="core">RLimitCPU</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ScriptInterpreterSource</name>
<description>CGI スクリプトのインタープリタの位置を調べるための手法</description>
<syntax>ScriptInterpreterSource Registry|Registry-Strict|Script</syntax>
<default>ScriptInterpreterSource Script</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context></contextlist>
<override>FileInfo</override>
<compatibility>Win32 のみ。
オプション <code>Registry-Strict</code> は Apache 2.0 以降で使用可能</compatibility>

<usage>
    <p>このディレクティブは、Apache で CGI スクリプトを
    実行する場合に利用するインタープリタを、
    どのように探し出すかについて制御するために使用します。
    デフォルトの設定は <code>Script</code> です。これはスクリプトの
    shebang 行 (最初の行で <code>#!</code> から始まるもの)
    に指されているインタープリタを使用します。Win32 ではその行は
    以下の様になります。</p>

    <example>
      #!C:/Perl/bin/perl.exe
    </example>

    <p>もしくは、<code>perl</code> が <code>PATH</code> にある場合は単に:</p>

    <example>
      #!perl
    </example>

    <p><code>ScriptInterpreterSource Registry</code> を指定すると、
    スクリプトファイルの拡張子 (例えば、<code>.pl</code>) を
    キーとして、Windows のレジストリツリー <code>HKEY_CLASSES_ROOT</code>
    を検索するようになります。レジストリのサブキー
    <code>Shell\ExecCGI\Command</code> か、それが存在しない場合は
    <code>Shell\Open\Command</code> がスクリプトファイルを開くために
    使われます。レジストリキーが見つからないときは、Apache は <code>Script</code>
    オプションが指定されたときの動作に戻ります。</p>

    <note type="warning"><title>セキュリティ</title> 
    <p><code>ScriptInterpreterSource Registry</code> を <directive
    module="mod_alias">ScriptAlias</directive> されたディレクトリで使うときは
    注意してください。Apache はそのディレクトリ中の<em>すべての</em>ファイルを
    実行しようとします。<code>Registry</code> という設定は通常は実行されない
    ファイルに対して望ましくないプログラムの実行が発生する可能性があります。
    例えば、ほとんどの Windows システムで、
    <code>.htm</code> ファイルのデフォルトの「開く」コマンドは
    Microsoft Internet Explorer を実行しますので、スクリプトに指定された
    ディレクトリにある <code>.htm</code> ファイルへのリクエストはサーバの
    バックグラウンドでブラウザを実行することになります。これは、一分内くらいで
    システムをクラッシュさるための良い方法です。</p>
    </note>

    <p>Apache 2.0 から導入されたオプション <code>Registry-Strict</code> は
    <code>Registry</code> と同じことを行ないますが、サブキー
    <code>Shell\ExecCGI\Command</code> のみを使います。
    <code>ExecCGI</code> キーは普通に使われるキーではありません。Windows 
    レジストリに手動で設定する必要がありますので、システムでの偶発的なプログラムの
    実行を防ぐことができます。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>ServerAdmin</name>
<description>サーバがクライアントに送るエラーメッセージに含める電子メールの
アドレス</description>
<syntax>ServerAdmin <var>email-address</var>|<var>URL</var></syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>

<usage>
    <p><directive>ServerAdmin</directive> は、クライアントに返すさまざまな
    エラーメッセージ中に記述する、
    問合せアドレスを設定します。与えられた引数を <code>httpd</code> が
    URL と認識しない場合は、<var>email-address</var> だと解釈して、
    ハイパーリンクのターゲットに <code>mailto:</code> を付けます。
    実際には、ここには電子メールアドレスを使うことが推奨されています。
    多くの CGI スクリプトはそうなっていることを仮定しています。
    URL を使う場合は、あなたの管理下にある別サーバを指すようにしてください。
    そうでないと、エラーが起こったときに連絡をすることができなくなって
    しまいます。
</p>

    <p>その際、これのために専用のアドレスを設定するのが良いでしょう。
    例えば、</p>

    <example>
      ServerAdmin www-admin@foo.example.com
    </example>

    <p>といったようにします。ユーザはいつもサーバに関する話であるということを
    明記してくるわけではありませんので。</p>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>ServerAlias</name>
<description>リクエストを名前ベースのバーチャルホストにマッチさせているときに
使用されるホストの別名</description>
<syntax>ServerAlias <var>hostname</var> [<var>hostname</var>] ...</syntax>
<contextlist><context>virtual host</context></contextlist>

<usage>
    <p><directive>ServerAlias</directive> ディレクティブは、<a
    href="../vhosts/name-based.html">ネームベースのバーチャルホスト</a>において
    使用するホストの別名を指定します。
    適切であれば、<directive>ServerAlias</directive> ディレクティブでは
    ワイルドカードを使うこともできます。</p>

    <example>
      &lt;VirtualHost *&gt;<br />
      ServerName server.domain.com<br />
      ServerAlias server server2.domain.com server2<br />
      # ...<br />
      &lt;/VirtualHost&gt;
    </example>
</usage>
<seealso><a href="../vhosts/">Apache バーチャルホスト説明書</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ServerName</name>
<description>サーバが自分自身を示すときに使うホスト名とポート</description>
<syntax>ServerName [<var>scheme</var>://]<var>fully-qualified-domain-name</var>[:<var>port</var>]</syntax>
<contextlist><context>server config</context><context>virtual host</context>
</contextlist>
<compatibility>このディレクティブはバージョン 2.0 ではバージョン 1.3 の
    <directive>Port</directive> ディレクティブの機能も含みます。</compatibility>

<usage>
    <p><directive>ServerName</directive> ディレクティブは、
    サーバが自分自身を示すスキーム名、ホスト名とポート番号を設定します。
    これは、リダイレクトする URL を生成する際に利用されます。
    例えば、ウェブサーバを動かしているマシンは <code>simple.example.com</code>
    で、DNS のエイリアス <code>www.example.com</code> もあるときに、
    ウェブサーバが後者として認識されて欲しいときは、以下のようにディレクティブを
    使います。</p>

    <example>
      ServerName www.example.com:80
    </example>

    <p><directive>ServerName</directive> が指定されていないときは、
    サーバは IP アドレスから逆引きを行なうことでホスト名を知ろうとします。
    <directive>ServerName</directive> にポートが指定されていないときは、
    サーバはリクエストが来ている
    ポートを使います。最高の信頼性と確実性をもたらすためには、
    <directive>ServerName</directive> を使ってホスト名とポートを明示的に
    指定してください。</p>

    <p><a href="../vhosts/name-based.html">名前ベースのバーチャルホスト</a>
    を利用している場合、<directive type="section" module="core"
    >VirtualHost</directive> セクション内の
    <directive>ServerName</directive> はこのバーチャルホストにマッチするために
    何がリクエストの Host: ヘッダに現れる必要があるのかを指定します。</p>

    <p>SSL を処理するデバイス、例えばリバースプロクシやロードバランサや
    SSL 処理軽減アプライアンスの裏側でサーバが稼動する場合もあるでしょう。
    そういった場合では、クライアントが接続するときに使う
    <code>https://</code> スキームとポート番号を <directive>ServerName</directive>
    ディレクティブで指定して、自己参照 URL が正しく生成できるようにします。</p>

    <p>自己参照 URL (例えば <module>mod_dir</module> モジュールによるものなど)
    が指定されたポートを使うか、クライアントのリクエストのポート番号を使うかを
    決定する設定は <directive module="core">UseCanonicalName</directive> 
    ディレクティブと <directive 
    module="core">UseCanonicalPhysicalPort</directive>
    ディレクティブを参照してください。</p>

</usage>

<seealso><a href="../dns-caveats.html">DNS と Apache に関する話</a></seealso>
<seealso><a href="../vhosts/">Apache バーチャルホスト説明書</a></seealso>
<seealso><directive module="core">UseCanonicalName</directive></seealso>
<seealso><directive module="core">UseCanonicalPhysicalPort</directive></seealso>
<seealso><directive module="core">NameVirtualHost</directive></seealso>
<seealso><directive module="core">ServerAlias</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ServerPath</name>
<description>非互換のブラウザが名前ベースのバーチャルホストにアクセスしたときの
ための互換用 URL パス名</description>
<syntax>ServerPath <var>URL-path</var></syntax>
<contextlist><context>virtual host</context></contextlist>

<usage>
    <p><directive>ServerPath</directive> ディレクティブは、<a
    href="../vhosts/">ネームベースのバーチャルホスト</a>において利用する
    互換用 URL パス名を設定します。</p>
</usage>
<seealso><a href="../vhosts/">Apache バーチャルホスト説明書</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ServerRoot</name>
<description>インストールされたサーバのベースディレクトリ</description>
<syntax>ServerRoot <var>directory-path</var></syntax>
<default>ServerRoot /usr/local/apache</default>
<contextlist><context>server config</context></contextlist>

<usage>
    <p><directive>ServerRoot</directive> ディレクティブは、
    サーバが存在するディレクトリを設定します。
    通常、<code>conf/</code> や <code>logs/</code> といったサブディレクトリが
    存在します。
    また、他の設定ディレクティブ (例えば <directive
    module="core">Include</directive> や <directive
    module="mod_so">LoadModule</directive> など) における相対パスは、
    このディレクトリからの相対位置となります。</p>

    <example><title>例</title>
      ServerRoot /home/httpd
    </example>


</usage>
<seealso><a href="../invoking.html"><code>httpd</code> の <code>-d</code>
    オプション</a></seealso>
<seealso><directive>ServerRoot</directive> の権限を適切に設定する方法は<a
     href="../misc/security_tips.html#serverroot">セキュリティのこつ</a></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ServerSignature</name>
<description>サーバが生成するドキュメントのフッタを設定</description>
<syntax>ServerSignature On|Off|EMail</syntax>
<default>ServerSignature Off</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>All</override>

<usage>
    <p><directive>ServerSignature</directive> ディレクティブは、
    サーバが生成するドキュメント
    (エラーメッセージ、<module>mod_proxy</module> における FTP のディレクトリリスト、
    <module>mod_info</module> の出力、等々)
    の最下行に付与するフッタの設定を行ないます。
    そのようなフッタ行を有効にしたい理由には、
    プロキシが複数連なっている場合に、ユーザはどのサーバが返した
    エラーメッセージかを知る手段がほとんど無いというものがあります。</p>


    <p>デフォルトである <code>Off</code> に設定をすると、フッタ行が抑制されます
    (そして、Apache-1.2 以前と互換の動作をします)。
    <code>On</code> に設定した場合は、単にドキュメントの中に、サーバのバージョン、
    稼動中のバーチャルホストの <a
    href="#servername">ServerName</a> の書かれた行を追加し、
    <code>EMail</code> にした場合はさらに参照されたドキュメントに対する <a
    href="#serveradmin">ServerAdmin</a> を指す "mailto:" が追加されます。</p>

    <p>バージョン 2.0.44 以降では、表示されるサーバーのバージョン番号の詳細は<directive
    module="core">ServerTokens</directive>
    ディレクティブにより制御されます。</p>
</usage>
<seealso><directive module="core">ServerTokens</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>ServerTokens</name>
<description><code>Server</code> HTTP 応答ヘッダを設定する</description>
<syntax>ServerTokens Major|Minor|Min[imal]|Prod[uctOnly]|OS|Full</syntax>
<default>ServerTokens Full</default>
<contextlist><context>server config</context></contextlist>

<usage>
    <p>このディレクティブは、クライアントに送り返す <code>Server</code>
    応答ヘッダ内に、サーバの一般的な OS 種別や、
    コンパイルされて組み込まれているモジュールの情報を
    含めるかどうかを指定します。</p>

    <dl>
      <dt><code>ServerTokens Prod[uctOnly]</code></dt>

      <dd>サーバは (例えば): <code>Server:
      Apache</code> といったように送ります。</dd>

      <dt><code>ServerTokens Major</code></dt>

      <dd>Server sends (<em>e.g.</em>): <code>Server:
      Apache/2</code></dd>

      <dt><code>ServerTokens Minor</code></dt>

      <dd>Server sends (<em>e.g.</em>): <code>Server:
      Apache/2.0</code></dd>

      <dt><code>ServerTokens Min[imal]</code></dt>

      <dd>サーバは (例えば): <code>Server:
      Apache/2.0.41</code> といったように送ります。</dd>

      <dt><code>ServerTokens OS</code></dt>

      <dd>サーバは (例えば): <code>Server: Apache/2.0.41
      (Unix)</code> といったように送ります。</dd>

      <dt><code>ServerTokens Full</code> (もしくは未指定)</dt>

      <dd>サーバは (例えば): <code>Server: Apache/2.0.41
      (Unix) PHP/4.2.2 MyMod/1.2</code> といったように送ります。</dd>
    </dl>

    <p>この設定はサーバ全体に適用され、バーチャルホスト上で有効にしたり
    無効にしたりはできません。</p>

    <p>バージョン 2.0.44 以降ではこのディレクティブは <directive
    module="core">ServerSignature</directive>
    ディレクティブにより表示される情報も制御します。</p>
</usage>
<seealso><directive module="core">ServerSignature</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>SetHandler</name>
<description>マッチするファイルがハンドラで処理されるようにする</description>
<syntax>SetHandler <var>handler-name</var>|None</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>
<compatibility>Apache 2.0 で core に移動</compatibility>

<usage>
    <p><code>.htaccess</code> や <directive type="section" module="core"
    >Directory</directive>
    セクション、<directive type="section" module="core">Location</directive>
    セクションに書かれた場合、
    このディレクティブはそこにあるすべてのファイルが
    <var>handler-name</var> で指定された<a href="../handler.html"
    >ハンドラ</a>で扱われることを強制します。例えば、拡張子に関わらず、
    ディレクトリ全体がイメージマップファイルとして解析して欲しい場合には、
    以下をそのディレクトリの <code>.htaccess</code>
    ファイルに記述します:</p>

    <example>
      SetHandler imap-file
    </example>

    <p>別の例: URL <code>http://servername/status</code>
    が指定されたときにサーバが状態報告をするようにしたいときは、以下を
    <code>httpd.conf</code> に記述します:</p>

    <example>
      &lt;Location /status&gt;<br />
      <indent>
        SetHandler server-status<br />
      </indent>
      &lt;/Location&gt;
    </example>

    <p><code>None</code> という値を設定することで、
    前の方の <directive>SetHandler</directive> で定義された設定を無効にすることが
    できます。</p>
    <p><strong>注意:</strong>SetHandler はデフォルトのハンドラをオーバーライド
    しますので、通常の挙動、たとえば、スラッシュ (/) で終わる URL が
    リクエストされたときにディレクトリやインデックスファイルを返すよう取り扱う挙動は、
    行われなくなります。
    </p>

</usage>

<seealso><directive module="mod_mime">AddHandler</directive></seealso>

</directivesynopsis>

<directivesynopsis>
<name>SetInputFilter</name>
<description>クライアントのリクエストや POST の入力を処理するフィルタを設定する</description>
<syntax>SetInputFilter <var>filter</var>[;<var>filter</var>...]</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>

<usage>
    <p><directive>SetInputFilter</directive> ディレクティブはクライアントの
    リクエストや POST の入力をサーバが受け取ったときに処理するフィルタを
    設定します。これは <directive module="mod_mime">AddInputFilter</directive>
    ディレクティブを含め、他の場所で定義されているフィルタの設定に
    追加されます。</p>

    <p>複数のフィルタを指定するときは、データを処理する順番に
    セミコロンで区切る必要があります。</p>

</usage>
<seealso><a href="../filter.html">フィルタ</a>説明書</seealso>
</directivesynopsis>

<directivesynopsis>
<name>SetOutputFilter</name>
<description>サーバの応答を処理するフィルタを設定する</description>
<syntax>SetOutputFilter <var>filter</var>[;<var>filter</var>...]</syntax>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context><context>.htaccess</context>
</contextlist>
<override>FileInfo</override>

<usage>
    <p><directive>SetOutputFilter</directive> ディレクティブは
    サーバの応答をクライアントに送り返される前に処理するフィルタを設定します。
    これは <directive module="mod_mime">AddOutputFilter</directive>
    ディレクティブを含め、他の場所で定義されているフィルタの設定に
    追加されます。</p>    

    <p>例えば、以下の設定は <code>/www/data/</code> ディレクトリのすべての
    ファイルを SSI で処理します。</p>

    <example>
      &lt;Directory /www/data/&gt;<br />
      <indent>
        SetOutputFilter INCLUDES<br />
      </indent>
      &lt;/Directory&gt;
    </example>

    <p>複数のフィルタを指定するときは、データを処理する順番に
    セミコロンで区切る必要があります。</p>
</usage>
<seealso><a href="../filter.html">フィルタ</a>説明書</seealso>
</directivesynopsis>

<directivesynopsis>
<name>TimeOut</name>
<description>各イベントについて、リクエストを失敗させるまでにサーバが
待つ時間を設定</description>
<syntax>TimeOut <var>seconds</var></syntax>
<default>TimeOut 60</default>
<contextlist><context>server config</context><context>virtual host</context></contextlist>

<usage>
    <p><directive>TimeOut</directive> ディレクティブは、
    様々な条件下での I/O 待ち時間を定義します:</p>

    <ol>
      <li>クライアントからのデータを読み込む時。
      受信バッファが空になっていて、TCP パケットが届くまで
      待つ時間の長さ</li>

      <li>クライアントに対してデータを送り出す時。
      送信バッファがいっぱいで、パケットの受信完了 <transnote>ACK</transnote> 
      が届くまで待つ時間の長さ</li>

      <li><module>mod_cgi</module> 内で、CGI スクリプトが出力を
      返すまでの待ち時間の長さ</li>

      <li><module>mod_ext_filter</module> 内で、フィルタ処理で出力を
      待つ時間の長さ</li>

      <li><module>mod_proxy</module> 内で、
      <directive module="mod_proxy">ProxyTimeout</directive>
      が設定されていない場合のデフォルトの待ち時間</li>
    </ol>

</usage>
</directivesynopsis>

<directivesynopsis>
<name>TraceEnable</name>
<description><code>TRACE</code> メソッドのリクエストに対する応答方法を決める
</description>
<syntax>TraceEnable <var>[on|off|extended]</var></syntax>
<default>TraceEnable on</default>
<contextlist><context>server config</context></contextlist>
<compatibility>Apache 1.3.34, 2.0.55 以降</compatibility>

<usage>
    <p>Apache のコア機能<transnote><module>core</module></transnote>と
    <module>mod_proxy</module> 両方の <code>TRACE</code>
    の挙動をオーバーライドします。デフォルトの <code>TraceEnable on</code>
    は、リクエストボディを受け入れないような、RFC2616 に準拠した
    <code>TRACE</code> リクエストを受け付けます。
    <code>TraceEnable off</code> と設定すると、コアサーバと
    <module>mod_proxy</module> は <code>405</code> (メソッド不許可)
    エラーをクライアントに返します。</p>

    <p>最後に、テストや調査目的などの限定用途として、仕様に準拠しない
    <code>TraceEnable extended</code> を使って、リクエストボディを
    受け付けるように挙動を変更できます。(オリジンサーバとしての)
    Apache のコアでは、リクエストボディのサイズは 64k (
    <code>Transfer-Encoding: chunked</code> が使われている場合は 
    chunk ヘッダ用に +8k) に制限されます。
    Apache のコアは、ヘッダと全ての chunk ヘッダをレスポンスの
    ボディとして返却します。
    proxy サーバとしては、リクエストボディのサイズは 64k に制限されません。</p>
</usage>
</directivesynopsis>

<directivesynopsis>
<name>UseCanonicalName</name>
<description>サーバが自分自身の名前とポートを決定する方法を設定する</description>
<syntax>UseCanonicalName On|Off|Dns</syntax>
<default>UseCanonicalName Off</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context></contextlist>

<usage>
    <p>多くの状況で Apache は<em>自己参照</em> URL、すなわち
    同じサーバを指す URL、を作成する必要があります。
    <code>UseCanonicalName On</code> の場合は、<directive 
    module="core">ServerName</directive> ディレクティブで指定されている
    ホスト名とポート番号を使って、その正規名 (自己参照の名前) を生成します。
    この名前は、すべての自己参照 URL で使われますし、CGI の 
    <code>SERVER_NAME</code> と <code>SERVER_PORT</code> でも使われます。</p>

    <p><code>UseCanonicalName Off</code> の場合、
    クライアントがホスト名とポートを指定したときには、
    それらを元に自己参照 URL を作成します (指定がなかったときは
    上の定義と同様にして正規名を解決します)。
    これらの値は<a href="../vhosts/name-based.html">名前ベースの
    バーチャルホスト</a>を実装で使われているのと同じ値で、
    同じクライアントで取得できる値になっています。
    CGI 変数 <code>SERVER_NAME</code> と <code>SERVER_PORT</code> 
    もクライアントから与えられた値から作成されます。</p>

    <p>このような挙動が便利な例は、イントラネットのサーバで <code>www</code>
    のような短い名前でユーザがマシンに接続するときです。
    ユーザの入力で短いホスト名が使われていて、URL が<em>最後のスラッシュ無しの</em>
    ディレクトリになっている <code>http://www/splat</code> のようなとき、
    Apache はリクエストを <code>http://www.domain.com/splat/</code> 
    へリダイレクトします。
    認証をするように設定していると、この場合
    ユーザは 2 回認証をしなければならなくなります (<code>www</code> に
    対して 1 回、<code>www.domain.com</code> に対してもう 1 回 -- 
    詳細は <a 
    href="http://httpd.apache.org/docs/misc/FAQ.html#prompted-twice">この話題の
    FAQ</a> を参照してください)。
    しかし <directive>UseCanonicalName</directive> が <code>Off</code> になっていると、
    Apache は <code>http://www/splat/</code> にリダイレクトします。</p>

    <p>三つ目のオプション <code>UseCanonicalName DNS</code> は、
    大規模な IP ベースのバーチャルホスティングで、
    <code>Host:</code> ヘッダを提供しない古いクライアントを
    サポートする場合を想定しています。
    このオプションでは Apache は、クライアントが接続した IP アドレスに対して
    DNS の逆引きを行なって、自己参照 URL を作成します。</p>

    <note type="warning"><title>警告</title>
    <p>CGI が <code>SERVER_NAME</code> に関して何らかの前提条件を
    仮定しているときには、このオプションの設定によっては動作しなく
    なるかもしれません。クライアントは実質的にはホスト名として
    何でも望みの値を指定することができます。CGI が
    <code>SERVER_NAME</code> を使って自己参照 URL を作成することしかしない
    場合は、どの設定を行なっても大丈夫なはずです。</p></note>
</usage>
<seealso><directive module="core">UseCanonicalPhysicalPort</directive></seealso>
<seealso><directive module="core">ServerName</directive></seealso>
<seealso><directive module="mpm_common">Listen</directive></seealso>
</directivesynopsis>

<directivesynopsis>
<name>UseCanonicalPhysicalPort</name>
<description>自分自身の名前とポート番号を解決する方法を設定する
</description>
<syntax>UseCanonicalPhysicalPort On|Off</syntax>
<default>UseCanonicalPhysicalPort Off</default>
<contextlist><context>server config</context><context>virtual host</context>
<context>directory</context></contextlist>

<usage>
    <p>さまざまな局面で <em>自己参照</em> URL -- それ自体のサーバを参照する URL
    を作ることになります。<code>UseCanonicalPhysicalPort On</code> と設定すると、
    <directive module="core">UseCanonicalName</directive> に従って別名を
    生成する場合に、実際の物理ポート番号を使って構成するようになります。
    <code>UseCanonicalPhysicalPort Off</code> の場合は、実際の物理ポート番号は
    使用せず、設定された情報を元にポート番号を決めます。</p>

    <note><title>注意</title>
    <p>物理ポートが使われる場合の順番は次のようになっています:<br /><br />
     <code>UseCanonicalName On</code></p>
     <ul>
      <li><code>ServerName</code> で指定されているポート番号</li>
      <li>物理ポート番号</li>
      <li>デフォルトのポート番号</li>
     </ul>
     <code>UseCanonicalName Off | DNS</code>
     <ul>
      <li><code>Host:</code> ヘッダをパースして取得されるポート番号</li>
      <li>物理ポート番号</li>
      <li><code>ServerName</code> で指定されているポート番号</li>
      <li>デフォルトのポート番号</li>
     </ul>
    
    <p><code>UseCanonicalPhysicalPort Off</code> で、
    物理ポート番号が上記の順序付けから除外されます。</p>
    </note>

</usage>
<seealso><directive module="core">UseCanonicalName</directive></seealso>
<seealso><directive module="core">ServerName</directive></seealso>
<seealso><directive module="mpm_common">Listen</directive></seealso>
</directivesynopsis>

<directivesynopsis type="section">
<name>VirtualHost</name>
<description>特定のホスト名や IP アドレスのみに適用されるディレクティブを
囲む</description>    
<syntax>&lt;VirtualHost
    <var>addr</var>[:<var>port</var>] [<var>addr</var>[:<var>port</var>]]
    ...&gt; ... &lt;/VirtualHost&gt;</syntax>
<contextlist><context>server config</context></contextlist>

<usage>
    <p><directive type="section">VirtualHost</directive> 及び
    <code>&lt;/VirtualHost&gt;</code> は、
    特定のバーチャルホストに対してのみ適用されるディレクティブ群を括る
    ために使われます。
    バーチャルホストコンテキストで許可される全てのディレクティブを指定可能です。
    サーバが、指定されたバーチャルホストにあるドキュメントへの
    リクエストを受け付けた場合、
    <directive type="section">VirtualHost</directive> セクションの中にある
    ディレクティブが適用されます。
    <var>Addr</var>は、次のものが利用できます:</p>

    <ul>
      <li>バーチャルホストの IP アドレス</li>

      <li>バーチャルホストの IP に対応する完全なドメイン名 (非推奨)</li>

      <li><code>NameVirtualHost *</code> と共に使われる、
      すべての IP アドレスにマッチする文字 <code>*</code></li>

      <li>IP ベースのバーチャルホストで他のものにマッチしない IP アドレス
      のための文字列 <code>_default_</code></li>
    </ul>

    <example><title>例</title>
      &lt;VirtualHost 10.1.2.3&gt;<br />
      <indent>
        ServerAdmin webmaster@host.example.com<br />
        DocumentRoot /www/docs/host.example.com<br />
        ServerName host.example.com<br />
        ErrorLog logs/host.example.com-error_log<br />
        TransferLog logs/host.example.com-access_log<br />
      </indent>
      &lt;/VirtualHost&gt;
    </example>
 
    <p>IPv6 アドレスはオプションのポート番号の指定と区別するために、
    角括弧で括って指定する必要があります。次は IPv6 の例です:</p>

    <example>
      &lt;VirtualHost [2001:db8::a00:20ff:fea7:ccea]&gt;<br />
      <indent>
        ServerAdmin webmaster@host.example.com<br />
        DocumentRoot /www/docs/host.example.com<br />
        ServerName host.example.com<br />
        ErrorLog logs/host.example.com-error_log<br />
        TransferLog logs/host.example.com-access_log<br />
      </indent>
      &lt;/VirtualHost&gt;
    </example>

    <p>各々のバーチャルホストにはそれぞれ違う IP アドレス、ポート番号
    もしくはホスト名に対応する必要があり、
    1 番目の場合には複数のアドレスで IP パケットを受信できるように
    サーバマシンを設定しなければなりません。
    (もし、マシンが複数のネットワークインターフェースを持たない場合は、
    (OSがサポートしていれば) <code>ifconfig alias</code> コマンドにより
    達成できます)。</p>

    <note><title>注意点</title>
    <p><directive type="section">VirtualHost</directive> は Apache が Listen する
    IP アドレスには影響を与え<strong>ません</strong>。
    <directive module="mpm_common">Listen</directive> を
    使って Apache が正しいアドレスを listen するように設定する必要があります。</p>
    </note>

    <p>IP ベースのバーチャルホストを使っている場合は、特別な名前
    <code>_default_</code> を指定することができます。その場合は
    そのバーチャルホストは他のバーチャルホストで明示的に挙げられていない
    すべての IP アドレスにマッチします。<code>_default_</code> バーチャルホストが無い
    場合に IP がバーチャルホストで指定されたものにマッチしないときは、
    VirtualHost セクションの外のすべての定義からなる「主」サーバ設定が
    使われます。(ただし、<directive
    module="core">NameVirtualHost</directive> ディレクティブにマッチする
    すべての IP アドレスは「主」サーバ設定も <code>_default_</code> バーチャルホストも
    使わないことに注意してください。詳しくは <a
    href="../vhosts/name-based.html">ネームベースのバーチャルホスト</a> を
    参照してください。)</p>

    <p><code>:port</code> といった形式で記述することにより、
    マッチさせるポートを変更可能です。
    この指定をしない場合には、主サーバ設定における
    一番最後に <code><a href="#port">Port</a></code> で指定されたポートが
    デフォルトとなります。
    <code>:*</code> を指定することにより、
    アドレス上の全てのポートにマッチします。(<code>_default_</code> のときは
    これを使うことが推奨されています。)</p>

    <p><directive type="section">VirtualHost</directive> ブロックごとに
    <directive module="core">ServerName</directive> を指定すべきです。
    もしなければ、メインサーバ設定の
    <directive module="core">ServerName</directive>
    が継承されます</p>

    <note type="warning"><title>セキュリティ</title>
    <p>サーバーを起動した以外のユーザがログファイルが保管されるディレクトリに
    書き込み可能なときになぜセキュリティが破られる可能性があるかの詳細は
    <a href="../misc/security_tips.html">セキュリティに関するコツ</a> を
    参照してください。</p></note>
</usage>
<seealso><a href="../vhosts/">Apache バーチャルホスト説明書</a></seealso>
<seealso><a href="../dns-caveats.html">DNS と Apache に関する話</a></seealso>
<seealso><a href="../bind.html">Apache が使用するアドレスとポートの設定</a></seealso>
<seealso>リクエストを受けた際にこれらの異なるセクションが
    組み合わされる方法については <a href="../sections.html">
    &lt;Directory&gt;, &lt;Location&gt;, &lt;Files&gt; セクションの動作法</a></seealso>
</directivesynopsis>

</modulesynopsis>
